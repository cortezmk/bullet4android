  \section{Wstęp}\label{sec:wstep}
  \subsection{Czym jest silnik fizyczny?}\label{subsec:czymJestSilnik}
\emph{TODO: Czym są i do czego wykorzystywane są silniki fizyczne. Czym różni
się silnik wysokoprecezyjny(High-precision) od silnika działającego w czasie
rzeczywistym(realtime) i gdzie znajdują swoje nalepsze zastosowanie. Ich
ograniczenia. Kilka najpopularniejszych silników. Trochę o PPU i GPGPU.}
  \subsection{Cele projektu.}\label{subsec:celeProjektu}
  \emph{TODO: Omówienie celów projektu:\\
  -przystosowanie silnika Bullet do funkcjonowania na platformie
  Andriod(wrapper dla języka java)\\
  -ocena przydatności silnika Bullet pod kątem realizmu symulacji w
  doświadczeniach fizycznych}
  \newpage
  \section{Wykorzystane technologie.}
  \emph{TODO: Krótkie omówienie technologii. Przy silniku Bullet uzasadnienie
  wyboru(open-source, realtime - przeznaczony do prezentowania symulacji na
  żywo)}
  \subsection{Android SDK}
TODO
  \subsection{Bullet physics engine}
TODO
  \subsection{Android NDK}
TODO
\subsection{OpenGL ES}
TODO
  \newpage
  \section{Wykorzystanie Android NDK jako wrappera silnika Bullet}
  \emph{TODO:dlaczego wykorzystany zostaje wrapper? - szybkość tworzenia sceny,
  łatwiejsze debugowanie, bezawaryjność}
  \subsection{Konfiguracja Android NDK w środowisku Eclipse}
  % [source]http://mhandroid.wordpress.com/2011/01/23/using-eclipse-for-android-cc-development/
  Aby utworzyć projekt Androida z możliwością edycji i kompilacji bibliotek
  natywnych należy: \\
  1. Zainstalować środowisko Eclipse(i doinstalować do niego wtyczkę
  \emph{ADT}).\\
  2. Pobrać kolejno \emph{Android SDK} i \emph{NDK}. Do edycji plików żródłowych
  jest też konieczne pobranie wtyczki \emph{CDT}(C++ Development Tools). Potrzebny
  będzie rónież kod żródłowy biblioteki Bullet. Dodatki w eclipse instaluje się
  przez Help $ \rightarrow $ Install new software\ldots , wpisując adres
  http://download.eclipse.org/releases/galileo (lub zamisat galileo wpisać nazwę swojej wersji Eclipse).
  
  \includegraphics[width=\textwidth]{./img/CDT.png}
  3. Utworzyć nowy standardowy projekt aplikacji na system Android.\\
  4. Do projektu dodać folder \emph{jni} gdzie przechowywany będzie kod źródłowy
  w języku C++. Skopiować do niego foldery z kodu źródłowego biblioteki
  Bullet(będą potrzebne biblioteki \emph{BulletCollision}, \emph{BulletDynamics}
  i \emph{LinearMath}, a także pliki \emph{btBulletCollisionCommon.h},
  \emph{btBulletDynamicsCommon.h}, \emph{Bullet-C-Api.h}).
  
  \begin{center}
  \includegraphics{./img/jni-folder.png}
  
  \includegraphics{./img/bulletFoldery.png}
  \end{center}
  
  5. Umieścić w folderze plik \emph{Android.mk} . Zawiera on informacje jak
  powinien być zbudowany projekt w kodzie natywnym. Do tego pliku należy
  dodać informacje o plikach źródłowych biblioteki Bullet.
  \lstinputlisting[language=make, caption=Zawartość pliku Android.mk,
  label=andMake, breaklines=true,numbers=left]{./listings/bulletMkfile.mk}
  
  6. Przekonwertować projekt java na java/C++ , przez menu File $ \rightarrow $
  New $ \rightarrow $ Other\ldots
  
  \includegraphics{./img/convert.png}
  
  7. W Properties projektu ustawić budowanie kodu w C++ przez \emph{ndk-build}.
  Najlepiej miejsce rozpakowania \emph{Android NDK} przypisać pod zmienną
  środowiskową (np. \$ \{NDKROOT\}), co ułatwi przenośność projektu.
  
  \includegraphics[width=\textwidth]{./img/properties.png}
  
  W zakładce behavior należy odznaczyć checkboxa \emph{Clean} i usunąć tekst z
  pola \emph{Build}.\\
  8. W C++ General $ \rightarrow $ Paths And Symbols dodać ścieżkę dla nagłówków.
 
  9. Ponieważ w projekcie będą wykorzystywane elementy biblioteki STL,
  konieczne jest dodanie odpowiedniej ścieżki.\\
  
  \includegraphics[width=\textwidth]{./img/ndkroot.png}
  
  Dodać również należy informację o wykorzystaniu STL w pliku
  \emph{Application.mk}(który również muisi być dodany do projektu).
  
  \lstinputlisting[language=make, caption=Zawartość pliku Application.mk,
  label=andMake]{./listings/Application.mk}
  
  Po tych czynnościach można edytować projekt ze składnią Javy jak i C++,
  korzystając z autouzupełniania i jednolitej kompilacji. Należy jednak
  pamiętać, że przy dodawaniu nowego pliku z kodem źródłowym w C++ do folderu
  \emph{jni} konieczne jest umieszczenie o nim informacji w \emph{Android.mk} .

\subsection{Wywoływanie funkcji natywnych z poziomu Javy}
\emph{TODO: w jaki sposób działa JNI?(przykładowy kod?)}

\subsection{Konserwacja obiektów}
\emph{TODO: w jaki sposób aplikacja kojarzy obiekty javy z obiektami natywnymi?}

\subsection{Przekazywanie argumentów i zwracanych wartości}
\emph{TODO: jak wygląda konwersja }

\subsection{Struktura wrappera}
\emph{TODO: Jak działąją sceny które są wykorzystywane w dalszych przykładach.
Głównie opisy pól i metod w klasach wrappera.}

\subsubsection{Typy podstawowe}

\subsubsection{Typy geometryczne}

\subsubsection{Typy fizyczne}

\paragraph{CollisionShape}

\paragraph{DynamicsWorld}

\paragraph{Spring}

\subsection{Rendering}
\emph{TODO: również klasa Camera. Jakie tryby OpenGL ES zostały wykorzystane
przy rysowaniu ramek.}

\subsection{Sceny}
\emph{TODO: bardzo krótki opis działania mechanizmu scen i gdzie dodawać ich
wywołania}

\newpage
\section{Implementacja i zastosowanie dodatkowych możliwośći silnika Bullet}
\emph{TODO: w jaki sposób zostały zaimplementowane pozostałe przydatne
mechanizmy silnika i jak zostały wykorzystane możliwości smartphone'a do
uatrakcyjnienia aplikacji:)}

\subsection{Akcelerometr}
\emph{TODO: omówienie przykładu ze sterowaniem grawitacją przy pomocy
akcelerometru.}

\subsection{Drag and Drop}
\emph{TODO: na razie point single touch. Jeśli mi się uda - również multitouch
z ``obszarowym'' dotykiem}

\subsection{DebugDrawer}
\emph{TODO: również opis problemu z przepełnieniem bufora JNI.}

\subsection{Wykrywanie kolizji}
\emph{TODO: o możliwości logowania kolizkji wybranych obiektów}

\section{Wykorzystanie silnika Bullet w doświadczeniach fizycznych}

\subsection{Gromadzenie pomiarów}

W celu łatwego gromadzenia danych pomiarowych w trakcie trwania testu powstała
klasa Logger przechowująca funkcje odpowiadające za przechowywanie danych w
pamięci urządzenia.
  \lstinputlisting[language=Java, caption=Klasa Logger,
  label=lis:logger]{./listings/Logger.java}
Należy również pamiętać o zezwoleniu aplikacji na manipulowanie pamięcią
zewnętrzną. Konieczny jest wpis w manifeście aplikacji.
\lstinputlisting[language=xml, caption=zawartość pliku AndroidManifest.xml,
  label=lis:manifest,linerange={6-9}]{./listings/AndroidManifest.xml}

\subsection{Zasada zachowania energii}
\emph{TODO: Czym jest energia kinetyczna liniowa i obrotowa. Jak jest zapisywana
w tym systemie? o momencie bezwładności}

\subsubsection{Przypadek z jednym ciałem}
Na początek zostanie rozważony najprostszy przypadek z jedną kulką odbijającą
się kolejno od dwóch idealnie sprężystych ścianek. Do tego testu wykorzystana
została scena prezentowana na listingu \ref{lis:SimpleSnookerScene}.
 \lstinputlisting[language=Java,
caption=scena testująca przypadek z jednym ciałem,
label=lis:SimpleSnookerScene]{./listings/SimpleSnookerScene.java}
Na niesprężystym(ln. 57) i całkowicie śliskim(ln. 55) podłożu zostaje
umieszczona kulka(ln. 59), która przez nadaną jej prędkość początkową(ln. 62)
odbija się kolejno od ścianek(ln. 49, 50). Sprężystość(\emph{restitution}) kulki jak i ścianek jest regulowana na
początku każdego testu(ln. 73, 74), która dla pierszego wynosi 0.9(ln. 18) i
jest liniowo zwiększana dla kolejnych dziesięciu testów(ln. 21, 24, 94) aż do
osiągnięcia wartości 1(gdzie teoretycznie energia kulki powinna być stała).
Dla każdej testowanej wartości przewidziano 20 odbić(ln. 22, 23, 81-97). Energia
kinetyczna kulki jest zapisywana do pliku przy każdym odbiciu(ln. 81-87).

\includegraphics[width=\textwidth]{./img/SimpleSnookerScene.png}

Zależność energii kinetycznej kulki przy kolejnych jej odbiciach od wartości
sprężystości jest przedstawiona na poniższym wykresie.

\input{./diag/EKjednoCialo.tex}

Jak widać w doświadczeniu nie osiągnięto spodziewanych rezultatów. Dla
sprężystości o wartości 1 energia kinetyczna powinna być stała, natomiast tutaj
gwałtownie wzrasta. Wydaje się, że dla utrzymania stałej energii kinetycznej
konieczne jest użycie niższej wartości. Dla polepszenia widoczności poniższy
wykres zawiera wartości energii kinetycznej dla wartości sprężystości od 0,94 do
0,97.

\input{./diag/EKjednoCialo2.tex}

Przy początkowej prędkości 5 m/s i masie 1 kg (linting
\ref{lis:SimpleSnookerScene} ln. 72, 59) energia kinetyczna kulki powinna mieć
stałą wartość energii kinetycznej 12,5.
\begin{center}
\scalebox{1.5}{$ E_{K} = \frac{mv^{2}}{2} = \frac{1kg*(5\frac{m}{s})^{2}}{2} =
12,5J $}\\
\end{center}
Z prezentowanego wykresu wynika, że najodpowiedniejsza wartość współczynnika
sprężystości kulki i ścianek mieści się między 0,945 a 0,955.\\
Dla ustalenia bardziej szczegółowej wartości test został powtórzony dla
następujących parametrów z listingu \ref{lis:SimpleSnookerScene}:

\lstinputlisting[language=Java,
  label=lis:SimpleSnookerScene_additional]{./listings/SimpleSnookerScene_additional.java}
  
Ilość odbić została zwiększona dwukrotnie, dzięki czemu możliwe jest sprawdzenie
czy wyrównany poziom energii będzie się utrzymywać.
  
\input{./diag/EKjednoCialo3.tex}

Jak widać poziom energii nie utrzymuje się dla zwiększonej ilości odbić. W
dodatku w losowych momentach (na prezentowanym wykresie dla wartości
współczynnika sprężystości 0,945 dla 27. odbicia) można zaobserwować jego
gwałtowne wzrosty. Dla złagodzenia efektów tych wzrostów na poniższym wykresie
przedstawiono uśredniony wynik dziesięciu testów.

\input{./diag/EKjednoCialo4.tex}

Spadki wartości energii kinetycznych sugerują, że nawet przy początkowo dobrze
dobranych współczynnikach sprężystości, przy większej ilości odbić energia nie
utrzymuje stałej wartości. Przy wartości współczynnika równej jedności energia
nie utrzymuje stałej wartości, a wzrasta. Co jest tego przyczyną? \\
W poszukiwaniu odpowiedzi na to pytanie można spojrzeć na wyniki poprzednich
testów rozpatrując osobno zapisy energii kinetycznej liniowej i obrotowej.
Poniżej przedstawiono fragment zapisu dla testu przy watrości współczynnika
sprężystości 0,98:

\lstinputlisting[language=xml, caption=wartości energii kinetycznej,
  label=lis:manifest,linerange={6-12}]{./listings/0,98.txt}
  
Można zaobserwować gwałtowne zmiany obu energii, jednak wzrost energii
kinetycznej liniowej jest zawsze poprzedzony wzrostem energii kinetycznej
obrotowej. Liniowa energia kinetyczna sama w sobie nie ulega gwałtownym
wzrostom. Przyczyną tego jest wzrost energii całkowitej.\\
Podczas analitycznego rozważania odbicia ciała możliwe jest dokładne ustalenie
czasu i miejsca zderzenia poprzez rozwiązanie odpowiedniego równania ruchu. W
przypadku symulacji zderzenia ciał przez silnik fizyczny, symulacja ta jest
dzielona na kroki. Każdy krok odpowiada minięciu kwantu czasu o z góry ustalonej
wartości i wszystkie ciała uczestniczące w symulacji poruszają się adekwatnie do
swojej prędkości. Prawie niemożliwe jest więc uzyskanie sytuacji w której
zderzenie powierzchni sferycznej z płaską będzie tylko jednym punktem.

\begin{center}
\includegraphics{./img/zderzenie1.png}
\end{center}

W przypadku zderzenia w symulacji zderzenie nie jest punktem a powierzchnią.
Silnik bullet do obliczenia parametrów reakcji na zderzenie potrzebuje
określenia obszaru zderzenia jako punktu (który jest wybrany z powierzchni
obszaru zderzenia oznaczonego na poniższej ilustracji czerwoną linią). Niestety
im większy jest obszar zderzenia tym większe jest prawdopodobieństwo błędu w
wyborze odpowiedniego punktu. Przesunięcie tego punktu względem właściwego
umiejscowienia pozycji zderzenia wynikające z niedokładności obliczeniowej
decyduje o nadmiarze lub niedoborze obrotowej energii kinetycznej.

\begin{center}
\includegraphics{./img/zderzenie2.png}
\end{center}

Aby zminimalizować możliwą wielkość obszaru zderzenia można zmniejszyć kwant
czasu, minimalizując odległości przebywane przez ciała w każdym kroku
symulacji.\\
Aby tego dokonać należy przyjrzeć się prototypowi funkcji \emph{stepSimulation}.

\lstinputlisting[language=c++,
label=lis:stepSimulation]{./listings/stepSimulation.cpp}

Funkcja ta jest wywoływana w celu zaktualizowania symulacji o pewien
czas(wywoływana jest dla każdej renderowanej klatki aplikacji). Według
\emph{Bullet User Manual}(TODO:źródło z bibliografii) jej poszczególne parametry
oznaczają:\\
\\
\textbf{timeStep}: całkowita ilość czasu jaka musi minąć w danym kroku. W
symulacjach jest to najczęściej odstęp czasu pomiędzy wyświetleniem poprzedniej
i następnej klatki.\\
\textbf{fixedTimeStep}: silnik Bullet każdy krok symulacji dzieli na podkroki o
długości okreslanej tym parametrem. To właśnie ten parametr decyduje o
dokładności symulacji. Jeśli \emph{timeStep} jest mniejsze od
\emph{fixedTimeStep} ruch ciał zostaje interpolowany. Domyślna wartość parametru
to $ \frac{1}{60} $ sekundy.\\
\textbf{maxSubSteps}: czasem z powodu spowolnień pracy silnika lub aplikacji
wartość \emph{timeStep} może być bardzo duża. Aby zapobiec zbyt dużym przeskokom
w animacji parametr ten określa maksymalną ilość podkroków jakie mogą być
wykonane w jednym kroku symulacji. Innymi słowy relacja parametrów powinna
wyglądać następująco:\\
$ timeStep < fixedTimeStep * maxSubSteps $

Domyślną wartością \emph{maxSubSteps} jest 1.

Kolejnym testem jest zmodyfikowany test z listingu \ref{lis:SimpleSnookerScene}.
Tym razem nie jest badana zależność energii kinetycznej od współczynnika
sprężystości, a od parametru \emph{fixedTimeStep}. 

\lstinputlisting[language=Java,
  label=lis:SimpleSnookerSceneFts,caption=scena
  testująca zależność energii
  kinetycznej od fixedTimeStep]{./listings/SimpleSnookerSceneFts.java}

Zależność energii kinetycznej od odbicia(poszczególne linie wykresu
reprezentują wartości współczynnika ftsFactor). Dla czytelności wykresu $
fixedTimeStep = \frac{1}{ftsFactor} $. Współczynnik sprężystości został
ustawiony na 1. Prędkość ciała wynosi 5$\frac{m}{s}$.

\input{./diag/EKjednoCialoFTS.tex}

Dla lepszej czytelności wykresu poniżej znajdują się wartości energii dla
pierwszych 15 odbić:

\input{./diag/EKjednoCialoFTSz.tex}

Z wyników można odczytać, że przy długości podkroku $ \frac{1}{260} $ sekundy
zasada zachowanaia energii zostaje spełniona. Okazuje się również, że wartość
tego parametru musi być odpowiednio dobrana(przy innych widoczne są
niedobory/nadmiary energii). Aby sprawdzić czy jest ona uniwersalna, kolejny
test zostanie przeprowadzony dla wartości prędkości 10$\frac{m}{s}$.

\input{./diag/EKjednoCialoFTS10.tex}

Jak widać odpowiednia wartość parametru \emph{fixedTimeStep} jest uzależniona od
wartości prędkości. Poprawne zasymulowanie doświadczenia w którym ważną rolę
odgrywają odbicia sprężyste przy użyciu silnika Bullet jest więc bardzo trudne.

\subsubsection{Przypadek z wieloma ciałami}

W poprzednim doświadczeniu został zbadany przypadek dla jednego ciała i dla
wartości kroku $ \frac{1}{260} $s i prędkości 5$ \frac{m}{s} $ energia
kinetyczna pozostaje stała. Jak wyglądać będzie zależność energii kinetycznej od
czasu w tych samych warunkach jeśli w symulacji będzie uczestniczyć wiele ciał?
Przy pomocy poniższej sceny sprawdzone zostanie jaki wpływ ma parametr
\emph{fixedTimeStep} na łączną energię poruszających się ciał.

\includegraphics[width=\textwidth]{./img/shot_2.png}

\lstinputlisting[language=Java,
  label=lis:ClosedSnookerScene,caption=scena
  testująca przypadek z wieloma ciałami]{./listings/ClosedSnookerScene3.java}
  
Na obszarze otoczonym ściankami(ln. 44-50) zostaje umieszczonych dziewięć(ln.
60-66) idealnie sprężystych(ln. 69) kulek. Kulki rozprzestrzeniają się w
losowych kierunkach z prędkością 5$ \frac{m}{s} $(ln. 64). Wartość energii
kinetycznej całego układu jest rejestrowana co 20 klatek(ln. 22, 105-111). Każdy
test trwa 20*100 klatek(ln. 22, 24, 94), w każdym z nich wartość parametru
\emph{ftsFactor} jest zwiększana(ln. 101).\\
Poniżej przedstawiono wykres zależności całkowitej energii układu od
czasu(klatek animacji) dla różnych wartości \emph{ftsFactor}, a tym samym
długości podkroku symulacji. Dla większej dokładności wykonane zostało dziesięć
takich testów i wyciągnięta zostałą z nich średnia wartość energii.

\input{./diag/EKwieleCial.tex}

Jak widać do pewnej wartości parametru \emph{ftsFactor}(dla prędkości 5$
\frac{m}{s} $: od 360 do 420) wartość łącznej energii rośnie w czasie. Po
przekroczeniu tej wartości energia zaczyna maleć. Dla wartości \emph{ftsFactor}
równej 260 energia układu nie pozostaje stała w czasie, jak miało to miejsce w
teście dla jednego ciała. Dzieje się tak ponieważ podczas symulacji ciała
poprzez zderzenia mogą przekazywać sobie energię. Niemożliwe jest przez to
utrzymanie stałej prędkości co powoduje, że dla każdego z ciał musi być
ustawiona inna wartość parametru \emph{fixedTmeStep}. Stabilność układu zostaje
więc naruszona.\\
Oznacza to, że silnik Bullet nie nadaje się do symulacji w których wymagane jest
badanie oddziaływań ciał sprężystych.\\
Fakt, że symulacje nie są dokładne dla wysokiego współczynnika sprężystości i
niskiego tarcia został nawet wspomniany w kodzie źródłowym biblioteki Bullet.

\lstinputlisting[language=c++, caption=fragment kodu pliku btRigidBody.h z
biblioteki Bullet,
label=lis:RigidBody,linerange={126-129}]{./listings/btRigidBody.h}

\subsection{Rzut ukośny}

\subsection{Równia pochyła}
\emph{TODO: porównanie czasów stoczenia się bez tarcia ciała kulistego i
sześciennego - obrotowa energia kinetyczna powinna spowolnić ciało kuliste}

\subsection{Zderzenie dwóch ciał}
\emph{TODO: jak zachowany jest pęd a jak energia? Można też zbadać odbicia pod
róznymi kątami}

\subsubsection{Zderzenie całkowicie sprężyste}

\subsubsection{Zderzenie całkowicie niesprężyste}

\subsection{Zderzenie trzech ciał}
\emph{TODO: czy rozpatrywane jest poprawnie?}

%\subsection{Odbicie podkręconej piłki}

\subsection{Kołyska Newtona}
\emph{TODO: jak zachowuje się energia?}

\subsection{Ciało na sprężynie}
\emph{TODO: j/w - przykład z pociskiem uderzającym w klocek na sprężynie?}

\subsection{Model ciała sprężystego}
\emph{TODO: jak zachowa się energia całego układu? - potrzebne źródło
teoretyczne}

\subsection{Gaz doskonały?}
\emph{TODO: Może spróbowaćby zasymulować kilka zamkniętych kulek. Porównać
wyniki pomiarów z wartościami teoretycznymi, wyznaczyć temperaturę, ciśnienie,
energię wewnętrzną, stałą gazową, czy zachowane jest równanie Clapeyrona? czy
słuszność ma równanie średniej drogi swobodnej?(można wykorzystać wykrywanie
kolizji)}

\newpage
\section{Wnioski}
\emph{Podsumowanie doświadczeń w pracy. Kiedy można wykorzystać silnik do
symulacji fizycznych? Można też zwalić część winy złych wyników na spadek
wydajności sprzętu przy dużym obciążeniu:).}
