  \section{Wstęp}\label{sec:wstep}
Od początku swojego istnienia komputery i ich moc obliczeniowa były
używane do rozwiązywania problemów fizycznych. Podczas II Wojny Światowej, ENIAC
- pierwszy elektroniczny komputer, był wykorzystywany przez armię Stanów Zjednoczonych do
przewidywania torów lotu pocisków balistycznych(uwzględniając m in. ich masę,
kąt wystrzelenia czy prędkość wiatru). W latach osiemdziesiątych superkomputery
były używane do oblicznaia dynamiki płynów, gdzie poszczególne cząstki były
reprezentowane przez wektory sił, które oddziaływując ze sobą symulowały
cyrkulację cieczy. Aby zwiększyć wydajność tej operacji zostały zaprojektowane
specjalne procesory wektorowe wykonujące operacje na wielu zmiennych
równocześnie. Współcześnie komputerowe wspomaganie obliczeń fizycznych jest
używane w wielu dziedzinach: m in. przez meteorologów do przewidywania zmian
warunków pogodowych, przetwarzania danych tuneli aerodynamicznych w lotnictwie,
czy doboru proporcji materiałów podczas projektowania produktów. Testowanie przy
pomocy symulacji komputerowych jest o wiele tańsze i bezpieczniejsze. Rosnące
zapotrzebowanie na wspomaganie obliczeń fizycznych spowodowało powstanie pojęcia
silnika fizycznego.
  \subsection{Czym jest silnik fizyczny?}\label{subsec:czymJestSilnik}
Silnik fizyczny to rodzaj oprogramowania komputerowego umożliwiającego
przybliżoną symulację pewnych systemów fizycznych jak np. dynamika bryły
sztywnej(w tym wykrywanie kolizji), ciał miękkich i płynów. Przeznaczony jest do
użytku w takich dziedzinach jak: grafika komputerowa, przemysł gier wideo czy
kinematografia. Czasem mianem silnika fizycznego jest również bardziej ogólnie
określane jakiekolwiek oprogramowanie symulujące zachowanie dowolnego
układu w sensie fizycznym.\\
Silniki fizyczne generalnie dzieli się na dwie klasy:\\
\textbf{Wysokoprecyzyjne}(\emph{high-precision}) - lub laboratoryjne.
Pochłaniają one całą(lub większość) mocy obliczeniowej platformy na której
działają aby wyniki ich obliczeń były jak najbardziej zgodne z rzeczywistymi.
Zwykle wykorzystywane są w przemyśle filmowym, prerenderowanych animacjach lub
laboratoriach do celów naukowych czy analiz technicznych. Najpopularniejszymi
dostępnymi publicznie wysokoprecyzyjnymi silnikami są:\\
- VisSim - stworzony przez Visual Solutions silnik fizyczny wykorzystujący
diagramy blokowe\\
- Working Model - komercyjny projekt wykorzystywany do wspomagania projektowania
konstrukcji inżynierskich.\\
\textbf{Wysokowydajnościowe}(\emph{high-performance})
- zwane również silnikami działającymi w czasie rzeczywistym(\emph{real-time
physics engines}), czy po prostu silnikami do gier wideo(\emph{video game
physics engines}). Są stosowane w przypadkach gdy od dokładności symulacji
ważniejszy jest krótki czas otrzymywania wyników, czyli w grach, czy
prezentowanych na żywo symulacjach. Nie wykorzystują one zasobów platformy w
takim stopniu co siniki wysokoprecyzyjne, więc mogą one działać na niemal każdym
sprzęcie, równocześnie obsługując np. rendering. Najpopularniejsze silniki
wysokowydajnościowe to:\\
komercyjne:\\
- Havok\\
- PhysX\\
- Vortex\\
niekomercyjne(\emph{open-source}):\\
- Bullet\\
- Box2D - silnik do symulacji dwuwymiarowych\\
- Newton Game Dynamics\\
- ODE(\emph{Open Dynamics Engine})\\
- PAL(\emph{Physics Abstraction Layer}) - API uwspólniające obsługę kilku innych
silników fizycznych\\

Pojęcie silnika fizycznego nie musi oznaczać tylko oprogramowania. W celu
zwiększenia wydajności symulacji fizycznych na osobistych platformach w 2006
roku narodziła się koncepcja sprzętowego wspomagania obliczeń, tak jak miało to
miejsce z renderingiem i kartami graficznymi. Firma Ageia opracowała PhysX -
pierwszy procesor PPU(\emph{Physics Processing Unit}). PhysX PPU posiadało
możliwość sprzętowego obliczania takich operacji jak dynamika bryły sztywnej, dynamika
ciałą miękkiego, detekcja kolizji, dynamika płynów, symulacja zachowania
elementów ubrań i włosów, analiza przy pomocy metody elementów skończonych.
Podczas demonstracji specjalnie napisanego dema na targach Consumer Electronics
Show 2006 komputer wyposażony w jednostkę PPU odtwarzał symulację z prędkością
30 fps, zaś tak samo skonfigurowana platforma bez wspomagania odtwarzał to samo
demo z prędkością 6 fps. Mimo wszystko koncepcja PPU nie osiągnęła sukcesu. Z
karty PhysX korzysta jedynie kilka gier. W 2008 roku udziały w firmie Ageia
zostały wykupione przez producenta kart graficznych GeForce - Nvidię. Firma
Nvidia wypuściła sterowniki pozwalające obsłużyć API PhysX na kartach GeForce,
tym samym PhysX już jako samo oprogramowanie stał się pierwszym silnikiem
fizycznym korzystającym ze sprzętowego wspomagania. Dało to również początek
koncepcji GPGPU(\emph{General Purpose processing on Graphics Processing Unit}),
czyli wykorzystywania mocy obliczeniowej kart graficznych do obliczeń związanych
z symulacjami fizycznymi. Firma AMD - producent kart Radeon, również oferuje
wsparcie dla tej technologii.

Pomimo swojej niewątpliwej przydatności silniki fizyczne posiadają również swoje
ograniczenia. Najważniejszym z nich jest skończona precyzja przeliczanych
wartości właściwa dla urządzeń cyfrowych. Jeśli precyzja jest niewystarczająca,
pozornie niewielkie błędy wynikające z zaokrąglania wyników mogą drastycznie
zmienić przebieg symulacji. Błędy są widoczne zwłaszcza w przypadkach gdy dwa
swobodne ciała oddziałują ze sobą z przemieszczeniem jednostkowym wymagającym
większej precyzji obliczeń niż silnik jest w stanie zaoferować. Zaobserwować
można wtedy nienaturalne ``trzęsienie się'' ciała. Można ten błąd wyeliminować
zwiększając precyzję obliczeń, jednak odbędzie się to kosztem mocy obliczeniowej
platformy.
\subsection{Cele projektu.}\label{subsec:celeProjektu}
Celami projektu są:\\

\textbf{Uruchomienie silnika fizycznego na mobilnej platformie Android.}\\
Istnieje wiele silników fizycznych dedykowanych na platformy
stacjonarne(głównie procesory firmy Intel). Silnik PhysX od wersji 3.0
posiada wsparcie dla platformy Android jednak do dziś nie istnieje żadne
oficjalne wsparcie open-source'owego silnika dla mobilnych platform. Ponieważ
kod źródłowy silnika Bullet jest ogólnie dostępny, możliwa jest jego kompilacja
na platformę ARM(najczęściej stosowane procesory w urządzeniach mobilnych).
Celem tej częsci pracy będzie sprawdzenie jakie ewentualne trudności może nieść
za sobą ta kompilacja. W celu ułatwienia tworzenia symulacji w silniku Bullet
zostanie stworzone proste obudowanie(\emph{wrapper}) dla języka Java.\\

\textbf{Wykorzystanie możliwości platformy mobilnej pod kątem symulacji
fizycznych.}\\ Smartfony i tablety posiadają kilka możliwości
najczęściej niedostępnych dla platform stacjonarnych(np. akcelerometry czy
ekrany dotykowe). Można je wykorzystać do uatrakcyjnienia symulacji, co
będzie celem tej części pracy.\\

\textbf{Ocena przydatności silnika w symulacjach fizycznych.}\\ Badany
silnik uruchomiony zostanie na platformie mobilnej, których to moc obliczeniowa
nie jest zwykle szczególnie wyskoa. Przez to wybrany silnik - Bullet nie jest
wysokoprecyzyjnym silnikiem fizycznym i nie można się spodziewać wyników
obliczeń bardzo zgodnych z rzeczywistością. Można jednak sprawdzić w jakich
warunkach symulacje będą wykonywane najdokładniej.
  \newpage
  \section{Wykorzystane technologie.}
  W projekcie zostały wykorzystana następujące technologie:
  \subsection{Android OS}
Bazujący na jądrze Linux system operacyjny zaprojektowany z myślą o
urządzeniach mobilnych z ekranami dotykowymi, takimi jak smartfony i tablety.
Początkowo tworzony przez Android Inc., później prawa do niego zostały wykupione
przez firmę Google. Kod źródłowy systemu jest ogólnodostępny na licencji Apache. 
Obecnie jest to najpopularniejszy system operacyjny na urządzenia mobilne.
Standardowo jest on instalowany na urządzeniach takich firm jak HTC, Motorola,
Samsung czy Sony Ericsson. Za sprawą wsparcia community, powstaje coraz większa
ilość aplikacji które są dystrybuowane za pośrednictwem uruchomionej przez
Google usługi Google Play(odpowiednik App Marketu na urządzenia firmy Apple).
  \subsection{Android SDK}
Android Software Development Kit to zestaw narzędzi deweloperskich służących do
tworzenia Aplikacji na platformę Android. W jeg oskład wchodzą debugger,
biblioteki, emulator oparty na QEMU, dokumentacja, przykłądowy kod oraz
tutoriale. Obecnie wspierane platformy to Linux, Mac OS X 10.5.8 lub nowszy,
Windows XP lub nowszy. Oficjalnym wspieranym środowiskiem programistycznym jest
Eclipse za pośrednictwem wtyczki ADT(\emph{Android Developer Tolls}). Aplikacje
są zwykle pisane w języku Java, jednakże Android nie posiada oficjalnej
implementacji JVM. Zamiast tego na potrzeby systemu powstała specjalna
wirtualna maszayna - Dalvik, która została zprojektowana z myślą o większej
oszczędności energii, czasu procesora i pamięci.
  \subsection{Bullet physics engine}
Bullet Physics jest obecnie najpopularniejszym darmowym, wysokowydajnościowym
silnikiem fizycznym z otwartym źródłem. Jest szeroko wykorzystywany w grach
wideo(m in. Grand Theft Auto 4, Gravitronix, Red Dead Redemption) jak i
mimo bycia sklasyfikowanym jako wysokowydajnościowy silnik, również w
kinematografii(2012, Shrek, Sherlock Holmes). Bullet jest również domyślnie
używanym silnikiem fizycznym ta takich projektach jak program graficzny
Blender czy silnik gier 3d OGRE.

\subsection{Android NDK}
Biblioteki napisane w kodzie natywnym(C/C++) mogą być kompilowane na platformę
ARM lub x86 i zainstalowane na urządzeniu używająć Android NDK(\emph{Native
Development Kit}). Natywne biblioteki mogą być uruchomione przez maszynę
wirtualną Dalvik używając metody \emph{System.LoadLibrary}. W przeciwieństwie do
Android SDK który bazuje na pluginach do Eclipsa, NDK jest zestawem narzędzi
wywoływanych z wiersza polecenia. Każde zbudowanie projektu musi więc odbyć się
ręcznie. Istnieją jednak wtyczki dla Eclipse od zewnętrznych producentów
pozwalające na automatyczną kompilację kodu natywnego. Dostęp do natywnych
funkcji z poziomu języka Java otrzymuje się poprzez JNI(\emph{Java Native
Interface}). W tym projekcie Android NDK będzie wykorzystane do kompilacji kodu
biblioteki Bullet na platformę ARM, oraz wywoływanie jej funkcji przez
integrację z kodem napisanym w języku Java.

\subsection{OpenGL ES}
To podzbiór graficznego API - OpenGL. Zostało zaprojektowane specjalnie na
potrzeby mobilnych urządzeń. Charakteryzuje się zbiorczym przetwarzaniem
danych, czyli do urządzenia graficznego przekazywane są całe bloki pamięci w
przeciwieństwie do charakterystycznych dla OpenGL pojedynczych wywołań. Jego
najnowsza wersja 3.0 jest obsługiwana przez systemy Android od wersji 2.2.

\newpage
\section{Podstawowe koncepcje silników fizycznych.}
Ponieważ silniki fizyczne są jedynie symulacją, nie można za ich pomocą dokonać
dokładnego odwzorowania rzeczistości. Dlatego w ich rozwiązaniach użyto
rozmaitych uproszczeń. W tej sekcji zostaną wymienione niektóre z nich.

\subsection{Detekcja kolizji}

\subsubsection{Bounding box}

\subsubsection{Otoczka wypłukła (convex hull)}

\subsubsection{Metoda elementów skończonych}

\subsection{Ruch Browna (Brownian motion)}

\subsection{Oddziaływania dynamiczne (paradigms)}
\emph{TODO: penalty methods, constraints(warunki), impulses}

  \newpage
  \section{Wykorzystanie Android NDK jako obudowania dla silnika Bullet}
Aby ułatwić tworzenie testowych scen zostało stworzone obudowanie obiektów
pozwalające korzystać z możliwości sinika Bullet z poziomu języka Java. Dzięki
temu proces tworzenia scen testowych zostaje skrócony oraz możliwe jest
debugowanie kodu w Eclipse IDE.
  \subsection{Konfiguracja Android NDK w środowisku Eclipse}
  % [source]http://mhandroid.wordpress.com/2011/01/23/using-eclipse-for-android-cc-development/
  Ponieważ w przeciwieństwie do Android SDK, dla NDK nie istnieje żadna
  oficjalna wtyczka automatyzująca kompilację natywnych bibliotek konieczna jest
  kompilacja ręczna z wiersza poleceń. Możliwe jest jednak skonfigurowanie
  środowiska Eclipse w celu integracji z NDK.
  
  Aby utworzyć projekt Androida z
  możliwością edycji i kompilacji bibliotek natywnych należy: \\
  1. Zainstalować środowisko Eclipse(i doinstalować do niego wtyczkę
  \emph{ADT}).\\
  2. Pobrać kolejno \emph{Android SDK} i \emph{NDK}. Do edycji plików żródłowych
  jest też konieczne pobranie wtyczki \emph{CDT}(C++ Development Tools). Potrzebny
  będzie rónież kod żródłowy biblioteki Bullet. Dodatki w eclipse instaluje się
  przez Help $ \rightarrow $ Install new software\ldots , wpisując adres
  http://download.eclipse.org/releases/galileo (lub zamisat galileo wpisać nazwę swojej wersji Eclipse).
  
  \includegraphics[width=\textwidth]{./img/CDT.png}
  3. Utworzyć nowy standardowy projekt aplikacji na system Android.\\
  4. Do projektu dodać folder \emph{jni} gdzie przechowywany będzie kod źródłowy
  w języku C++. Skopiować do niego foldery z kodu źródłowego biblioteki
  Bullet(będą potrzebne biblioteki \emph{BulletCollision}, \emph{BulletDynamics}
  i \emph{LinearMath}, a także pliki \emph{btBulletCollisionCommon.h},
  \emph{btBulletDynamicsCommon.h}, \emph{Bullet-C-Api.h}).
  
  \begin{center}
  \includegraphics{./img/jni-folder.png}
  
  \includegraphics{./img/bulletFoldery.png}
  \end{center}
  
  5. Umieścić w folderze plik \emph{Android.mk} . Zawiera on informacje jak
  powinien być zbudowany projekt w kodzie natywnym. Do tego pliku należy
  dodać informacje o plikach źródłowych biblioteki Bullet.
  \lstinputlisting[language=make, caption=Zawartość pliku Android.mk,
  label=andMake, breaklines=true,numbers=left]{./listings/bulletMkfile.mk}
  
  6. Przekonwertować projekt java na java/C++ , przez menu File $ \rightarrow $
  New $ \rightarrow $ Other\ldots
  
  \includegraphics{./img/convert.png}
  
  7. W Properties projektu ustawić budowanie kodu w C++ przez \emph{ndk-build}.
  Najlepiej miejsce rozpakowania \emph{Android NDK} przypisać pod zmienną
  środowiskową (np. \$ \{NDKROOT\}), co ułatwi przenośność projektu.
  
  \includegraphics[width=\textwidth]{./img/properties.png}
  
  W zakładce behavior należy odznaczyć checkboxa \emph{Clean} i usunąć tekst z
  pola \emph{Build}.\\
  8. W C++ General $ \rightarrow $ Paths And Symbols dodać ścieżkę dla nagłówków.
 
  9. Ponieważ w projekcie będą wykorzystywane elementy biblioteki STL,
  konieczne jest dodanie odpowiedniej ścieżki.\\
  
  \includegraphics[width=\textwidth]{./img/ndkroot.png}
  
  Dodać również należy informację o wykorzystaniu STL w pliku
  \emph{Application.mk}(który również muisi być dodany do projektu).
  
  \lstinputlisting[language=make, caption=Zawartość pliku Application.mk,
  label=andMake]{./listings/Application.mk}
  
  Po tych czynnościach można edytować projekt ze składnią Javy jak i C++,
  korzystając z autouzupełniania i jednolitej kompilacji. Należy jednak
  pamiętać, że przy dodawaniu nowego pliku z kodem źródłowym w C++ do folderu
  \emph{jni} konieczne jest umieszczenie o nim informacji w \emph{Android.mk} .

\subsection{Wywoływanie funkcji natywnych z poziomu Javy}
Do wywoływania funkcji natywnych z poziomu języka Java Android NDK wykorzystuje
interfejs JNI. Aby dodać w kodzie C/C++ funkcję możliwą do wywałania z
wirtualnej maszyny Dalvik, w kodzie w języku Java należy użyć słowa kluczowego
\emph{native}.

\lstinputlisting[language=java, linerange={1-2, 9-9, 25-25}, caption=Użycie
słowa kluczowego native w języku Java, label=lis:javaNative]{./listings/CollisionShape.java}

Następnie w kodzie natywnym zaimplementować zarejestrowaną metodę przy pomocy
nazewnictwa Java\_<nazwa\_paczki>\_<nazwa\_obiektu>\_<nazwa\_metody>, oraz
makra JNIEXPORT. Funkcja taka posiada dwa stałe argumenty. Pierwszym argumentem
funkcji jest wskaźnik na zmienną typu \emph{JNIEnv}, która jest interfejsem
środowiska uruchomieniowego Javy. Drugim jest zmienna typu \emph{jobject}
zawierająca referencję do obiektu wywołującego daną metodę.

\lstinputlisting[language=c++, linerange={3-4, 21-22}, caption=Implementacja
natywnej metody w kodzie c++,
label=lis:cppNative]{./listings/CollisionShape.cpp}

W kodzie nie może również zabraknąć odniesienia do pliku \emph{jni.h}.

\begin{lstlisting}[language=c++, caption=Użycie pliku nagłówkowego]
#include <jni.h>
\end{lstlisting}

\subsection{Kontener obiektów}
Ponieważ niemożliwy jest bezpośredni dostęp do obiektów po stronie natywnej,
w tym projekcie zostają zastosowane obiekty obudowujące. Po stronie Javy każdy
obiekt posiada unikalny identyfikator, który zostaje mu nadany przez
konstruktor w momencie jego tworzenia.

\lstinputlisting[language=java, linerange={5-6, 9-9, 26-31}, caption=Tworzenie
nowego obiektu obudowującego,
label=lis:javaGenId]{./listings/DynamicsWorld.java}

W kodzie natywnym wszystkie identyfikatory są przechowywane w mapie
\emph{pointer\_map} z biblioteki STL. Za jej pomocą kojarzone są identyfikatory
obudowujących obiektów Javy z obiektami biblioteki Bullet.

\lstinputlisting[language=c++, caption=Zawartość pliku btObjects.h\,
zawierającego mapę, label=lis:btObjects_h]{./listings/btObjects.h}

Funkcje \emph{put} i \emph{get} służą do umieszczania i pobierania obiektów
biblioteki Bullet z mapy.

\lstinputlisting[language=c++, caption=Zawartość pliku btObjects.cpp\,
implementującego kontener identyfikatorów,
label=lis:btObjects_h]{./listings/btObjects.cpp}

Z każdym wywołaniem metody \emph{put} zostaje zwiększony licznik
\emph{pointer\_map\_count}(ln. 10) dzięki czemu każy obiekt dodany do mapy
posiada unikalny identyfikator.\\
Następnie w implementacji metody \emph{constructor} przy
pomocy funkcji \emph{put} zostaje nadany nowy identyfikator i
przekazany(zwrócony) obiektowi obudowującemu z listingu \ref{lis:javaGenId}.

\begin{lstlisting}[language=c++, caption=Użycie mapy pointer\_map w
funkcji constructor.]
extern "C"
{
	JNIEXPORT jint Java_org_bulletSamples_physics_DynamicsWorld_constructor( JNIEnv* env, jobject self )
	{
		//inicjalizacja skladowych obiektow btDiscreteDynamicsWorld
		btDiscreteDynamicsWorld* dynamicsWorld = new
		btDiscreteDynamicsWorld(dispatcher,broadphase,solver,collisionConfiguration);
		return btObjects::put(dynamicsWorld);
	}
}
\end{lstlisting}

Aby uzyskać dostęp do przechowywanego przez mapę obiektu należy użyć metody
\emph{get}, przekazując jej otrzymaną przez parametr wartość \emph{id}. Ponieważ
mapa koajarzy identyfikatory ze wskaźnikami typu \emph{void\*}, pobrana wartość
musi być przerzutowana na odpowiedni typ.

\begin{lstlisting}[language=c++, caption=Pobranie przechowywanego obiektu z
mapy] extern "C"
{
	JNIEXPORT void Java_org_bulletSamples_physics_DynamicsWorld_NCreateBox( JNIEnv* env, jobject self, jint id ...) 
	 {
	 	btDiscreteDynamicsWorld* dw = (btDiscreteDynamicsWorld*)btObjects::get(id);
	 	//wykonywanie operacji na pobranym obiekcie
	}
}
\end{lstlisting}

Całą sekwencję tworzenia i wykonywania akcji na obiektach przedstawiono na
poniższym diagramie.

\begin{center}
\includegraphics[width=\textwidth]{./img/sequenceDiagram.png}
\end{center}

\subsection{Struktura biblioteki obudowującej}
W celu ułatwienia składania scen testowych część klas biblioteki Bullet została
opakowana w klasach języka Java. Strukturę zawierającej je paczki przedstawia
poniższy schemat.
\begin{center}
\includegraphics[scale=0.5]{./img/packageDiagram.png}
\end{center}

\subsubsection{Typy geometryczne}
Poza klasami odpowiadającymi za podstawową geometrię jak wektor(\emph{Vector3})
i kwaternion(\emph{Quaternion}), paczka \emph{org.bulletTest.geometry} zawiera
również klasy deiniujące kształty - prostopadłościan(\emph{Box}) i
kulę(\emph{Sphere}). Klasy \emph{Box} i \emph{Sphere} posiadają
odpowiednie metody pozwalające na renderowanie określonych kształtów
o podanych rozmiarach.

\subsubsection{Typy fizyczne}
Dostępne metody obiektów opakowujących klasy silnika Bullet zostały
przedstawione poniżej.

\paragraph{DynamicsWorld}
Klasa przedstawia środowisko fizyczne. Dodawane są do niego symulowane bryły
sztywne i sprężyny.\\ \\
\input{./tab/DynamicsWorld.tex}

\paragraph{CollisionShape}
Klasa przedstawia symulowane obiekty brył sztywnych.\\ \\
\input{./tab/CollisionShape.tex}

\paragraph{Spring}
Klasa przedstawia symulowane obiekty ciał sprężystych.\\
W parametrach funkcji można znaleźć typ enumeracyjny \emph{DoF} -
stopnie swobody(\emph{degrees of freedom}). Określają one do jakiego stopnia
swobody odnosi się dane wywołanie metody. Dostępne wartości to:\\
\input{./tab/DoF.tex}
\\ \\
Do zaobrazowania znaczenia poszczególnych parametrów funkcji klasy Spring
zostanie wykorzystana poniższa scena:\\

\lstinputlisting[language=java, caption=Scena demonstrująca użycie klasy Spring,
label=lis:spring_demo]{./listings/spring_demo.java}

\begin{figure}
\centering
\includegraphics[scale = 0.6]{./img/Spring-render.png}
\caption{Render sceny z listingu \ref{lis:spring_demo}.}
\label{fig:spring_demo}
\end{figure}

Opisy metod w poniższej tabeli odnoszą się do oznaczeń na rysunku
\ref{fig:spring_demo}. Wszystkie metody działąjące na stopień swobody sprężyny
odnoszą się do ciała oznaczonego przez \textbf{B}.\\
\input{./tab/Spring.tex}

\subsection{Przekazywanie argumentów i zwracanych wartości}
Podczas wymiany argumentów przez funkcje między wirtualną maszyną Javy a kodem
natywnym podstawowe typy danych(jak \emph{int} czy \emph{float}) zostają
przekonwertowane przez interfejs JNI na im odpowiadające dla danego środowiska.
Natomiast gdy przekazywane są typy złożone(jak \emph{Vector3} i
\emph{Quaternion} w bibliotece \emph{org.bulletTest.geometry}), wartości
otrzymywane w parametrach to referencje na dany obiekt. W takich przypadkach
konwersja musi być wykonana przez kod aplikacji poprzez pobranie i odpowiednie
przypisanie pól z typami podstawowymi. Poniższy listing przedstawia metodę
zamieniającą obiekt Javy \emph{Vector3} na natywny obiekt klasy \emph{btVector3}
z biblioteki Bullet.

\lstinputlisting[language=c++, caption=Konwersja klasy Vector3 z obiektu Javy
do obiektu natywnego., label=lis:jnVector3Conv,
linerange={39-50}]{./listings/common.cpp}

Parametr \emph{env} to referencja do środowiska uruchomieniowego Javy,
\emph{obj} jest referencją na obiekt Javy \emph{Vector3}, a \emph{vec} to
zwrócony przekonwertowany obiekt \emph{btVector3}. Przy pomocy metody
\emph{GetObjectlClass}(ln. 3) zostaje pobrana zmienna reprezentująca klasę
obiektu \emph{obj}, która zostaje wykorzystana przez metody
\emph{GetFieldId}(ln. 4-6) do pobrania reprezentacji pól obiektu. Następnie za
ich pomocą wyciągnięte zostają same wartości pól - współrzędnych \emph{x},
\emph{y} i \emph{z} wektora(ln. 8-10), które zostają wykorzystane do stworzenia
nowego obiektu natywnego klasy \emph{btVector3}. Analogicznie realizowana jest
konwersja obiektów natywnych na obiekty Javy.

\subsection{Zwalnianie pamięci}
Gdy dany opakowujący klasę biblioteki Bullet obiekt przestaje być potrzebny
należy zwolnić zajmowaną przez niego pamięć. Niestety wbudowany w maszynę
wirtualną Dalvik odśmiecacz pamięci(\emph{garbage collector}) nie może usunąć
obiektu natywnego. Do tego celu wymagane jest zaimplementowanie destruktora dla
klasy opakowującej. Pierwszym krokiem jest przeciążenie metody \emph{finalize}
wywoływanej podczas usuwania obiektu Javy przez odśmiecacz.

\begin{lstlisting}[language=Java, caption=Przeciążenie metody \emph{finalize}
na przykładzie klasy \emph{DynamicsWorld}] public class DynamicsWorld
{
	...
	native private void destructor(int id);
	...
	protected void finalize() throws Throwable
	{
		destructor(id);
		super.finalize();
	}
	...
}
\end{lstlisting}

Następnie należy zaimplementować funkcję destruktora w kodzie natywnym.

\begin{lstlisting}[language=c++, caption=Implementacja funkcji
\emph{destructor} na przykładzie klasy \emph{DynamicsWorld}]
JNIEXPORT void Java_org_bulletSamples_physics_DynamicsWorld_destructor( JNIEnv* env, jobject self, jint id )
{
	delete (btDiscreteDynamicsWorld*)btObjects::get(id);
	btObjects::remove(id);
}
\end{lstlisting}

W linijce 3 pobierany jest wskaźnik na obiekt typu
\emph{btDiscreteDynamicsWorld} a następnie wskazywany przez niego obiekt jest
usuwany za pomocą polecenia \emph{delete}. W linijce 4 usuwany jest
identyfikator wraz z wskaźnikiem na nieistniejący już obiekt z mapy
\emph{btObjects}.

\subsection{Sceny}
W celu ułatwienia dodawania kolejnych testów silnika powstał mechanizm scen,
które można wymieniać przed kompilacją aplikacji. Każda scena zawiera właściwe
dla siebie obiekty fizyczne i związane z nimi instrukcje. Klasa \emph{BaseScene}
jest klasą bazową dla wszystkich scen w projekcie.

\begin{figure}
\centering
\includegraphics[scale=0.6]{./img/SceneClassDiagram.png}
\caption{Diagram reprezentujący klasę SimpleScene.}
\label{fig:sceneClassDiagram}
\end{figure}

Każda scena posiada własny egzemplarz klasy \emph{DynamicsWorld} nadawana jej
przez konstruktor. Przeciążając metody \emph{create}, \emph{update} i
\emph{render} można na scenie wykonać każdą akcję.

\newpage
\section{Implementacja i zastosowanie dodatkowych możliwośći silnika Bullet}
\emph{TODO: w jaki sposób zostały zaimplementowane pozostałe przydatne
mechanizmy silnika i jak zostały wykorzystane możliwości smartphone'a do
uatrakcyjnienia aplikacji:)}

\subsection{Akcelerometr}
%http://developer.android.com/guide/topics/sensors/sensors_overview.html
\emph{TODO: omówienie przykładu ze sterowaniem grawitacją przy pomocy
akcelerometru.}

\subsection{Przeciągnij i upuść}\label{sec:dragAndDrop}
\emph{TODO: na razie point single touch. Jeśli mi się uda - również multitouch
z ``obszarowym'' dotykiem}

\subsection{Klasa DebugDrawer}\label{sec:debugDrawer}
\emph{TODO: również opis problemu z przepełnieniem bufora JNI.}

\subsection{Wykrywanie kolizji}
\emph{TODO: o możliwości logowania kolizkji wybranych obiektów}

\newpage
\section{Wykorzystanie silnika Bullet w doświadczeniach fizycznych}

\subsection{Gromadzenie pomiarów}

W celu łatwego gromadzenia danych pomiarowych w trakcie trwania testu powstała
klasa Logger przechowująca funkcje odpowiadające za przechowywanie danych w
pamięci urządzenia.
  \lstinputlisting[language=Java, caption=Klasa Logger,
  label=lis:logger]{./listings/Logger.java}
Należy również pamiętać o zezwoleniu aplikacji na manipulowanie pamięcią
zewnętrzną. Konieczny jest wpis w manifeście aplikacji.
\lstinputlisting[language=xml, caption=zawartość pliku AndroidManifest.xml,
  label=lis:manifest,linerange={6-9}]{./listings/AndroidManifest.xml}

\subsection{Zasada zachowania energii}
Zasada zachowania energii to jedna z fundamentalnych zasad mechaniki klasycznej.
Stwierdza ona, że w układzie izolowanym suma wszystkich rodzajów energii układu
jest stała (nie zmienia się w czasie). W konsekwencji, energia w układzie
izolowanym nie może być ani utworzona, ani zniszczona, może jedynie zmienić się
jej forma.\\
Ponieważ w testach wykonywanych w tym podrozdziale nie są zakładane
oddziaływania pomiędzy ciałami, zostaną rozważone jedynie zmiany energii
kinetycznej. Badanymi ciałami są bryły sztywne(\emph{rigid bodies}), więc brane
pod uwagę będą dwa rodzaje tej energii: liniowa oraz obrotowa.\\
\textbf{Liniowa energia kinetyczna}\\
Jest to energia jaką posiada ciało za sprawą bycia w ruchu. Jest zdefinowana
jako wartość pracy jaka jest wymagana do wprowadzenia będącego w stanie
spoczynku ciała w ruch z ustaloną prędkością. Wyrażana jest przez:
\begin{equation}
E_{K} = \frac{mv^{2}}{2}
\end{equation}
Gdzie \emph{m} to masa ciała, a \emph{v} to jego prędkość.\\
W klasie \emph{CollisionShape} jest wyrażana przez:

\lstinputlisting[language=java, caption=fragment pliku
CollisionShape.java,
label=lis:LinearEK,linerange={137-140}]{./listings/CollisionShape.java}

\textbf{Obrotowa energia kinetyczna}\\
Jest to rodzaj energii właściwy dla ciał nie będących pojedynczymi punktami a
zbiorem punktów materialnych, charakteryzujących się poza pozycją równiez
obrotem. Zdefinowana jest jako wartość pracy jaka jest wymagana do wprowadzenia
ciała w ruch obrotowy z daną prędkością kątową. Wyrażana jest przez:
\begin{equation}
E_{K} = \frac{I\omega^{2}}{2}
\end{equation}
Gdzie:\\
$ \omega $ to wartość prędkości kątowej ciała względem jego środka masy\\
\emph{I} to skalarna wartość momentu bezwładności ciała\\
Moment bezwładności(\emph{moment of inertia}) to miara miara bezwładności ciała
w ruchu obrotowym względem określonej, ustalonej osi obrotu. Odgrywa prawie taką samą
rolę w dynamice ruchu obrotowego jak masa w dynamice ruchu postępowego, opisując
relacje między momentem pędu, energią kinetyczną a prędkością kątową jak masa
między pędem, energią kinetyczną a prędkością. Moment bezwładności pojedynczego
punktu materialnego jest iloczynem jego masy \emph{m} i kwadratu odległości od
osi obrotu \emph{r}:
\begin{equation}
I = mr^{2}
\end{equation}

\begin{center}
\includegraphics{./img/inertia.png}
\end{center}

Zaś dla ciałą składającego się z \emph{n} punktów moment bezwładności jest sumą
momentów bezwładności wszystkich punktów.
\begin{equation}
I = \sum_{i=1}^{n} m_{i}r_{i}^{2}
\end{equation}
Dla zaimplementowanych kształtów w omawianynej bibliotece obudowującej wartości
momentu bezwładności są następujące:\\
Dla kuli(\emph{sphere}):\\
\begin{center}
\includegraphics{./img/inertiaSphere.png}
\end{center}
\begin{equation}
I = \frac{2}{5}mr^{2}
\end{equation}
Dla prostopadłościanu(\emph{box}):\\
\begin{center}
\includegraphics{./img/inertiaBox.png}
\end{center}
Dla dowolnej osi obrotu $ \hat{n} $ przechodzącej przez środek masy sześcianu
moment bezwładności jest określany przez następuące równanie:
\begin{equation}
I = m\hat{n}^{T}\hat{I}\hat{n} = m
\begin{bmatrix}n_{1}&n_{2}&n_{3}\end{bmatrix}
\begin{bmatrix}y^{2}+z^{2}&-xy&-xz\\-yx&x^{2}+z^{2}&-yz\\-zx&-zy&x^{2}+y^{2}\end{bmatrix}
\begin{bmatrix}n_{1}\\n_{2}\\n_{3}\end{bmatrix}
\label{eq:boxInertia}
\end{equation}
Wartości \emph{x}, \emph{y} i \emph{z}, to kolejno szerokość, wysokość i długość
rozważanego prostopadłościanu.\\
Nie jest konieczne implementowanie momentu bezwładności osobno dla każdego typu
bryły. Silnik bullet przechowuje wartość macierzy momentu bezwładności dla
każdego obiektu klasy \emph{btRigidBody}.

\lstinputlisting[language=c++, caption=fragment pliku
btRigidBody.h,
label=lis:RigidBodyh,linerange={55-60}]{./listings/btRigidBody.h}

Pole \emph{m\_invInertiaTensorWorld} zawiera odwrotną macierz momentu
bezwładności w odniesieniu do macierzy świata symulacji.

\lstinputlisting[language=c++, caption=fragment pliku
CollisionShape.cpp,
label=lis:CollisionShapecpp,linerange={162-168}]{./listings/CollisionShape.cpp}

W 6. linijce listingu \ref{lis:CollisionShapecpp} realizowane jest mnożenie wektorów
\emph{n} (transpozycja jest realizowana przez iloczyn skalarny(\emph{dot}) dwóch
powstałych wektorów) z równaia \ref{eq:boxInertia}.

\lstinputlisting[language=java, caption=fragment pliku
CollisionShape.java,
label=lis:CollisionShapejava,linerange={38-38,142-145,
147-153}]{./listings/CollisionShape.java}

Ponieważ wyciągana wartość w kodzie natywnym to odwrotna wartość momentu
bezwładności, w linijce 4 zostaje ona sprowadzona do wartości prawidłowej. Jako
oś obrotu zostaje obrany znormalizowany wektor prędkości kątowej(ln. 10).\\
\textbf{Całkowita energia kinetyczna}\\
Podsumowując, dla testów w tym podrozdziale sprawdzone zostanie czy spełniony
jest następujący warunek dla \emph{n} ciał:
\begin{equation}
E_{K} = \sum_{i=1}^{n}\left(\frac{mv^{2}}{2} + \frac{I\omega^{2}}{2}\right) =
const.
\end{equation}
Warunek jest sprawdzany przez metodę:
\lstinputlisting[language=java, caption=fragment
pliku CollisionShape.java,
label=lis:CollisionShapejava2,linerange={155-158}]{./listings/CollisionShape.java}

\subsubsection{Przypadek z jednym ciałem}
Na początek zostanie rozważony najprostszy przypadek z jedną kulką odbijającą
się kolejno od dwóch idealnie sprężystych ścianek. Do tego testu wykorzystana
została scena prezentowana na listingu \ref{lis:SimpleSnookerScene}.
 \lstinputlisting[language=Java,
caption=scena testująca przypadek z jednym ciałem,
label=lis:SimpleSnookerScene]{./listings/SimpleSnookerScene.java}
Na niesprężystym(ln. 57) i całkowicie śliskim(ln. 55) podłożu zostaje
umieszczona kulka(ln. 59), która przez nadaną jej prędkość początkową(ln. 62)
odbija się kolejno od ścianek(ln. 49, 50). Sprężystość(\emph{restitution})
kulki jak i ścianek jest regulowana na początku każdego testu(ln. 73, 74),
która dla pierszego wynosi 0.9(ln. 18) i jest liniowo zwiększana dla kolejnych
dziesięciu testów(ln. 21, 24, 94) aż do osiągnięcia wartości 1(gdzie
teoretycznie energia kulki powinna być stała).
Dla każdej testowanej wartości przewidziano 20 odbić(ln. 22, 23, 81-97). Energia
kinetyczna kulki jest zapisywana do pliku przy każdym odbiciu(ln. 81-87).

\begin{center}
\includegraphics[scale = 0.5]{./img/SimpleSnookerScene.png}
\end{center}

Zależność energii kinetycznej kulki przy kolejnych jej odbiciach od wartości
sprężystości jest przedstawiona na poniższym wykresie.

\input{./diag/EKjednoCialo.tex}

Jak widać w doświadczeniu nie osiągnięto spodziewanych rezultatów. Dla
sprężystości o wartości 1 energia kinetyczna powinna być stała, natomiast tutaj
gwałtownie wzrasta. Wydaje się, że dla utrzymania stałej energii kinetycznej
konieczne jest użycie niższej wartości. Dla polepszenia widoczności poniższy
wykres zawiera wartości energii kinetycznej dla wartości sprężystości od 0,94 do
0,97.

\input{./diag/EKjednoCialo2.tex}

Przy początkowej prędkości 5$\frac{m}{s}$ i masie 1 kg (linting
\ref{lis:SimpleSnookerScene} ln. 72, 59) energia kinetyczna kulki powinna mieć
stałą wartość energii kinetycznej 12,5.
\begin{equation}
E_{K} = \frac{mv^{2}}{2} = \frac{1kg*(5\frac{m}{s})^{2}}{2} =
12,5J
\end{equation}
Z prezentowanego wykresu wynika, że najodpowiedniejsza wartość współczynnika
sprężystości kulki i ścianek mieści się między 0,945 a 0,955.\\
Dla ustalenia bardziej szczegółowej wartości test został powtórzony dla
następujących parametrów z listingu \ref{lis:SimpleSnookerScene}:

\lstinputlisting[language=Java,
  label=lis:SimpleSnookerScene_additional]{./listings/SimpleSnookerScene_additional.java}
  
Ilość odbić została zwiększona dwukrotnie, dzięki czemu możliwe jest sprawdzenie
czy wyrównany poziom energii będzie się utrzymywać.
  
\input{./diag/EKjednoCialo3.tex}

Jak widać poziom energii nie utrzymuje się dla zwiększonej ilości odbić. W
dodatku w losowych momentach (na prezentowanym wykresie dla wartości
współczynnika sprężystości 0,945 dla 27. odbicia) można zaobserwować jego
gwałtowne wzrosty. Dla złagodzenia efektów tych wzrostów na poniższym wykresie
przedstawiono uśredniony wynik dziesięciu testów.

\input{./diag/EKjednoCialo4.tex}

Spadki wartości energii kinetycznych sugerują, że nawet przy początkowo dobrze
dobranych współczynnikach sprężystości, przy większej ilości odbić energia nie
utrzymuje stałej wartości. Przy wartości współczynnika równej jedności energia
nie utrzymuje stałej wartości, a wzrasta. Co jest tego przyczyną? \\
W poszukiwaniu odpowiedzi na to pytanie można spojrzeć na wyniki poprzednich
testów rozpatrując osobno zapisy energii kinetycznej liniowej i obrotowej.
Poniżej przedstawiono fragment zapisu dla testu przy watrości współczynnika
sprężystości 0,98:

\lstinputlisting[language=xml, caption=wartości energii kinetycznej,
  label=lis:manifest,linerange={6-12}]{./listings/0,98.txt}
  
Można zaobserwować gwałtowne zmiany obu energii, jednak wzrost energii
kinetycznej liniowej jest zawsze poprzedzony wzrostem energii kinetycznej
obrotowej. Liniowa energia kinetyczna sama w sobie nie ulega gwałtownym
wzrostom. Przyczyną tego jest wzrost energii całkowitej.\\
Podczas analitycznego rozważania odbicia ciała możliwe jest dokładne ustalenie
czasu i miejsca zderzenia poprzez rozwiązanie odpowiedniego równania ruchu. W
przypadku symulacji zderzenia ciał przez silnik fizyczny, symulacja ta jest
dzielona na kroki. Każdy krok odpowiada minięciu kwantu czasu o z góry ustalonej
wartości i wszystkie ciała uczestniczące w symulacji poruszają się adekwatnie do
swojej prędkości. Prawie niemożliwe jest więc uzyskanie sytuacji w której
zderzenie powierzchni sferycznej z płaską będzie tylko jednym punktem.

\begin{center}
\includegraphics{./img/zderzenie1.png}
\end{center}

W przypadku zderzenia w symulacji zderzenie nie jest punktem a powierzchnią.
Silnik Bullet do obliczenia parametrów reakcji na zderzenie potrzebuje
określenia obszaru zderzenia jako punktu (który jest wybrany z powierzchni
obszaru zderzenia oznaczonego na poniższej ilustracji czerwoną linią). Niestety
im większy jest obszar zderzenia tym większe jest prawdopodobieństwo błędu w
wyborze odpowiedniego punktu. Przesunięcie tego punktu względem właściwego
umiejscowienia pozycji zderzenia wynikające z niedokładności obliczeniowej
decyduje o nadmiarze lub niedoborze obrotowej energii kinetycznej.

\begin{center}
\includegraphics{./img/zderzenie2.png}
\end{center}

Aby zminimalizować możliwą wielkość obszaru zderzenia można zmniejszyć kwant
czasu, minimalizując odległości przebywane przez ciała w każdym kroku
symulacji.\\
Aby tego dokonać należy przyjrzeć się prototypowi funkcji \emph{stepSimulation}.

\lstinputlisting[language=c++,
label=lis:stepSimulation]{./listings/stepSimulation.cpp}

Funkcja ta jest wywoływana w celu zaktualizowania symulacji o pewien
czas(wywoływana jest dla każdej renderowanej klatki aplikacji). Według
\emph{Bullet User Manual}(TODO:źródło z bibliografii) jej poszczególne parametry
oznaczają:\\
\\
\textbf{timeStep}: całkowita ilość czasu jaka musi minąć w danym kroku. W
symulacjach jest to najczęściej odstęp czasu pomiędzy wyświetleniem poprzedniej
i następnej klatki.\\
\textbf{fixedTimeStep}: silnik Bullet każdy krok symulacji dzieli na podkroki o
długości okreslanej tym parametrem. To właśnie ten parametr decyduje o
dokładności symulacji. Jeśli \emph{timeStep} jest mniejsze od
\emph{fixedTimeStep} ruch ciał zostaje interpolowany. Domyślna wartość parametru
to $ \frac{1}{60} $ sekundy.\\
\textbf{maxSubSteps}: czasem z powodu spowolnień pracy silnika lub aplikacji
wartość \emph{timeStep} może być bardzo duża. Aby zapobiec zbyt dużym przeskokom
w animacji parametr ten określa maksymalną ilość podkroków jakie mogą być
wykonane w jednym kroku symulacji. Innymi słowy relacja parametrów powinna
wyglądać następująco:\\
\begin{equation}
timeStep < fixedTimeStep * maxSubSteps
\end{equation}

Domyślną wartością \emph{maxSubSteps} jest 1.

Kolejnym testem jest zmodyfikowany test z listingu \ref{lis:SimpleSnookerScene}.
Tym razem nie jest badana zależność energii kinetycznej od współczynnika
sprężystości, a od parametru \emph{fixedTimeStep}. 

\lstinputlisting[language=Java,
  label=lis:SimpleSnookerSceneFts,caption=scena
  testująca zależność energii
  kinetycznej od fixedTimeStep]{./listings/SimpleSnookerSceneFts.java}

Zależność energii kinetycznej od odbicia(poszczególne linie wykresu
reprezentują wartości współczynnika ftsFactor). Dla czytelności wykresu $
fixedTimeStep = \frac{1}{ftsFactor} $. Współczynnik sprężystości został
ustawiony na 1. Prędkość ciała wynosi 5$\frac{m}{s}$.

\input{./diag/EKjednoCialoFTS.tex}

Dla lepszej czytelności wykresu poniżej znajdują się wartości energii dla
pierwszych 15 odbić:

\input{./diag/EKjednoCialoFTSz.tex}

Z wyników można odczytać, że przy długości podkroku $ \frac{1}{260} $ sekundy
zasada zachowanaia energii zostaje spełniona. Okazuje się również, że wartość
tego parametru musi być odpowiednio dobrana(przy innych widoczne są
niedobory/nadmiary energii). Aby sprawdzić czy jest ona uniwersalna, kolejny
test zostanie przeprowadzony dla wartości prędkości 10$\frac{m}{s}$.

\input{./diag/EKjednoCialoFTS10.tex}

Jak widać odpowiednia wartość parametru \emph{fixedTimeStep} jest uzależniona od
wartości prędkości. Poprawne zasymulowanie doświadczenia w którym ważną rolę
odgrywają odbicia sprężyste przy użyciu silnika Bullet jest więc bardzo trudne.

\subsubsection{Przypadek z wieloma ciałami}

W poprzednim doświadczeniu został zbadany przypadek dla jednego ciała i dla
wartości kroku $ \frac{1}{260} $s i prędkości 5$ \frac{m}{s} $ energia
kinetyczna pozostaje stała. Jak wyglądać będzie zależność energii kinetycznej od
czasu w tych samych warunkach jeśli w symulacji będzie uczestniczyć wiele ciał?
Przy pomocy poniższej sceny sprawdzone zostanie jaki wpływ ma parametr
\emph{fixedTimeStep} na łączną energię poruszających się ciał.

\begin{center}
\includegraphics[scale = 0.5]{./img/shot_2.png}
\end{center}

\lstinputlisting[language=Java,
  label=lis:ClosedSnookerScene,caption=scena
  testująca przypadek z wieloma ciałami]{./listings/ClosedSnookerScene3.java}
  
Na obszarze otoczonym ściankami(ln. 44-50) zostaje umieszczonych dziewięć(ln.
60-66) idealnie sprężystych(ln. 69) kulek. Kulki rozprzestrzeniają się w
losowych kierunkach z prędkością 5$ \frac{m}{s} $(ln. 64). Wartość energii
kinetycznej całego układu jest rejestrowana co 20 klatek(ln. 22, 105-111). Każdy
test trwa 20*100 klatek(ln. 22, 24, 94), w każdym z nich wartość parametru
\emph{ftsFactor} jest zwiększana(ln. 101).\\
Poniżej przedstawiono wykres zależności całkowitej energii układu od
czasu(klatek animacji) dla różnych wartości \emph{ftsFactor}, a tym samym
długości podkroku symulacji. Dla większej dokładności wykonane zostało dziesięć
takich testów i wyciągnięta zostałą z nich średnia wartość energii.

\input{./diag/EKwieleCial.tex}

Jak widać do pewnej wartości parametru \emph{ftsFactor}(dla prędkości 5$
\frac{m}{s} $: od 360 do 420) wartość łącznej energii rośnie w czasie. Po
przekroczeniu tej wartości energia zaczyna maleć. Dla wartości \emph{ftsFactor}
równej 260 energia układu nie pozostaje stała w czasie, jak miało to miejsce w
teście dla jednego ciała. Dzieje się tak ponieważ podczas symulacji ciała
poprzez zderzenia mogą przekazywać sobie energię. Niemożliwe jest przez to
utrzymanie stałej prędkości co powoduje, że dla każdego z ciał musi być
ustawiona inna wartość parametru \emph{fixedTmeStep}. Stabilność układu zostaje
więc naruszona.\\
Oznacza to, że silnik Bullet nie nadaje się do symulacji w których wymagane jest
badanie oddziaływań ciał sprężystych.\\
Fakt, że symulacje nie są dokładne dla wysokiego współczynnika sprężystości i
niskiego tarcia został nawet wspomniany w kodzie źródłowym biblioteki Bullet.

\lstinputlisting[language=c++, caption=fragment kodu pliku btRigidBody.h z
biblioteki Bullet,
label=lis:RigidBody,linerange={126-129}]{./listings/btRigidBody.h}

\subsection{Rzut ukośny}

\subsection{Równia pochyła}
\emph{TODO: porównanie czasów stoczenia się bez tarcia ciała kulistego i
sześciennego - obrotowa energia kinetyczna powinna spowolnić ciało kuliste}

\subsection{Zderzenie dwóch ciał}
\emph{TODO: jak zachowany jest pęd a jak energia? Można też zbadać odbicia pod
róznymi kątami}

\subsubsection{Zderzenie całkowicie sprężyste}

\subsubsection{Zderzenie całkowicie niesprężyste}

\subsection{Zderzenie trzech ciał}
\emph{TODO: czy rozpatrywane jest poprawnie?}

%\subsection{Odbicie podkręconej piłki}

\subsection{Kołyska Newtona}
\emph{TODO: jak zachowuje się energia?}

\subsection{Ciało na sprężynie}
\emph{TODO: j/w - przykład z pociskiem uderzającym w klocek na sprężynie?}

\subsection{Model ciała sprężystego}
\emph{TODO: jak zachowa się energia całego układu? - potrzebne źródło
teoretyczne}

\subsection{Gaz doskonały?}
\emph{TODO: Może spróbowaćby zasymulować kilka zamkniętych kulek. Porównać
wyniki pomiarów z wartościami teoretycznymi, wyznaczyć temperaturę, ciśnienie,
energię wewnętrzną, stałą gazową, czy zachowane jest równanie Clapeyrona? czy
słuszność ma równanie średniej drogi swobodnej?(można wykorzystać wykrywanie
kolizji)}

\newpage
\section{Wnioski}
\emph{Podsumowanie doświadczeń w pracy. Kiedy można wykorzystać silnik do
symulacji fizycznych? Można też zwalić część winy złych wyników na spadek
wydajności sprzętu przy dużym obciążeniu:).}
