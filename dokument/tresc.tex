  \section{Wstęp}\label{sec:wstep}
Od początku swojego istnienia komputery i ich moc obliczeniowa były
używane do rozwiązywania problemów fizycznych. Podczas II Wojny Światowej, ENIAC
- pierwszy elektroniczny komputer, był wykorzystywany przez armię Stanów Zjednoczonych do
przewidywania torów lotu pocisków balistycznych (uwzględniając m in. ich masę,
kąt wystrzelenia czy prędkość wiatru). W latach osiemdziesiątych superkomputery
były używane do oblicznaia dynamiki płynów, gdzie poszczególne cząstki były
reprezentowane przez wektory sił, które oddziaływując ze sobą symulowały
cyrkulację cieczy. Aby zwiększyć wydajność tej operacji zostały zaprojektowane
specjalne procesory wektorowe wykonujące operacje na wielu zmiennych
równocześnie. Współcześnie komputerowe wspomaganie obliczeń fizycznych jest
używane w wielu dziedzinach: m in. przez meteorologów do przewidywania zmian
warunków pogodowych, przetwarzania danych z tuneli aerodynamicznych w
lotnictwie, czy doborze proporcji materiałów podczas projektowania produktów. Testowanie
przy pomocy symulacji komputerowych jest o wiele tańsze i bezpieczniejsze. Rosnące
zapotrzebowanie na wspomaganie obliczeń fizycznych spowodowało powstanie pojęcia
silnika fizycznego.
  \subsection{Czym jest silnik fizyczny?}\label{subsec:czymJestSilnik}
Silnik fizyczny to rodzaj oprogramowania komputerowego umożliwiającego
przybliżoną symulację pewnych systemów fizycznych jak np. dynamika bryły
sztywnej (w tym wykrywanie kolizji), ciał miękkich i płynów. Przeznaczony jest
do użytku w takich dziedzinach jak: grafika komputerowa, przemysł gier wideo czy
kinematografia. Czasem mianem silnika fizycznego jest również bardziej ogólnie
określane jakiegokolwiek oprogramowania symulującego zachowanie dowolnego
układu w sensie fizycznym.\\
Silniki fizyczne generalnie dzieli się na dwie klasy:\\
\textbf{Wysokoprecyzyjne} (\emph{high-precision}) - lub laboratoryjne.
Pochłaniają one całą (lub większość) mocy obliczeniowej platformy na której
działają aby wyniki ich obliczeń były jak najbardziej zgodne z rzeczywistymi.
Zwykle wykorzystywane są w przemyśle filmowym, prerenderowanych animacjach lub
laboratoriach do celów naukowych czy analiz technicznych. Najpopularniejszymi
dostępnymi publicznie wysokoprecyzyjnymi silnikami są:\\
- VisSim - stworzony przez Visual Solutions silnik fizyczny wykorzystujący
diagramy blokowe\\
- Working Model - komercyjny projekt wykorzystywany do wspomagania projektowania
konstrukcji inżynierskich.\\
\textbf{Wysokowydajnościowe} (\emph{high-performance})
- zwane również silnikami działającymi w czasie rzeczywistym (\emph{real-time
physics engines}), czy po prostu silnikami do gier wideo (\emph{video game
physics engines}). Są stosowane w przypadkach gdy od dokładności symulacji
ważniejszy jest krótki czas otrzymywania wyników, czyli w grach, czy
prezentowanych na żywo symulacjach. Nie wykorzystują one zasobów platformy w
takim stopniu co siniki wysokoprecyzyjne, więc mogą one działać na niemal każdym
sprzęcie, równocześnie obsługując np. rendering. Najpopularniejsze silniki
wysokowydajnościowe to:\\
komercyjne:\\
- Havok\\
- PhysX\\
- Vortex\\
niekomercyjne (\emph{open-source}):\\
- Bullet\\
- Box2D - silnik do symulacji dwuwymiarowych\\
- Newton Game Dynamics\\
- ODE (\emph{Open Dynamics Engine})\\
- PAL (\emph{Physics Abstraction Layer}) - API uwspólniające obsługę kilku
innych silników fizycznych\\

Pojęcie silnika fizycznego nie musi oznaczać tylko oprogramowania. W celu
zwiększenia wydajności symulacji fizycznych na osobistych platformach w 2006
roku narodziła się koncepcja sprzętowego wspomagania obliczeń, tak jak miało to
miejsce z renderingiem i kartami graficznymi. Firma Ageia opracowała PhysX -
pierwszy procesor PPU (\emph{Physics Processing Unit}). PhysX PPU posiadało
możliwość sprzętowego obliczania takich operacji jak dynamika bryły sztywnej, dynamika
ciała miękkiego, detekcja kolizji, dynamika płynów, symulacja zachowania
elementów ubrań i włosów, analiza przy pomocy metody elementów skończonych.
Podczas demonstracji specjalnie napisanego dema na targach Consumer Electronics
Show 2006 komputer wyposażony w jednostkę PPU odtwarzał symulację z prędkością
30 fps, zaś tak samo skonfigurowana platforma bez wspomagania odtwarzała to samo
demo z prędkością 6 fps. Mimo wszystko koncepcja PPU nie osiągnęła sukcesu. Z
karty PhysX korzysta jedynie kilka gier. W 2008 roku udziały w firmie Ageia
zostały wykupione przez producenta kart graficznych GeForce - Nvidię. Firma
Nvidia wypuściła sterowniki pozwalające obsłużyć API PhysX na kartach GeForce,
tym samym PhysX już jako samo oprogramowanie stał się pierwszym silnikiem
fizycznym korzystającym ze sprzętowego wspomagania. Dało to również początek
koncepcji GPGPU (\emph{General Purpose processing on Graphics Processing Unit}),
czyli wykorzystywania mocy obliczeniowej kart graficznych do obliczeń związanych
z symulacjami fizycznymi. Firma AMD - producent kart Radeon, również oferuje
wsparcie dla tej technologii.

Pomimo swojej niewątpliwej przydatności silniki fizyczne posiadają również swoje
ograniczenia. Najważniejszym z nich jest skończona precyzja przeliczanych
wartości właściwa dla urządzeń cyfrowych. Jeśli precyzja jest niewystarczająca,
pozornie niewielkie błędy wynikające z zaokrąglania wyników mogą drastycznie
zmienić przebieg symulacji. Błędy są widoczne zwłaszcza w przypadkach gdy dwa
swobodne ciała oddziałują ze sobą z przemieszczeniem jednostkowym wymagającym
większej precyzji obliczeń niż silnik jest w stanie zaoferować. Zaobserwować
można wtedy nienaturalne ``trzęsienie się'' ciała. Można ten błąd wyeliminować
zwiększając precyzję obliczeń, jednak odbędzie się to kosztem mocy obliczeniowej
platformy.

\subsection{Cele projektu.}\label{subsec:celeProjektu}
Celami projektu są:\\

\textbf{Uruchomienie silnika fizycznego na mobilnej platformie Android.}\\
Istnieje wiele silników fizycznych dedykowanych na platformy
stacjonarne (głównie procesory firmy Intel). Silnik PhysX od wersji 3.0
posiada wsparcie dla platformy Android jednak do dziś nie istnieje żadne
oficjalne wsparcie open-source'owego silnika dla mobilnych platform. Ponieważ
kod źródłowy silnika Bullet jest ogólnie dostępny, możliwa jest jego kompilacja
na platformę ARM (najczęściej stosowane procesory w urządzeniach mobilnych).
Celem tej częsci pracy będzie sprawdzenie jakie ewentualne trudności może nieść
za sobą ta kompilacja. W celu ułatwienia tworzenia symulacji w silniku Bullet
zostanie stworzone proste obudowanie (\emph{wrapper}) dla języka Java.\\

\textbf{Wykorzystanie możliwości platformy mobilnej pod kątem symulacji
fizycznych.}\\ Smartfony i tablety posiadają kilka możliwości
najczęściej niedostępnych dla platform stacjonarnych (np. akcelerometry czy
ekrany dotykowe). Można je wykorzystać do uatrakcyjnienia symulacji, co
będzie celem tej części pracy.\\

\textbf{Ocena przydatności silnika w symulacjach fizycznych.}\\ Badany
silnik uruchomiony zostanie na platformie mobilnej, których to moc obliczeniowa
nie jest zwykle szczególnie wysoka. Przez to wybrany silnik - Bullet nie jest
wysokoprecyzyjnym silnikiem fizycznym i nie można się spodziewać wyników
obliczeń bardzo zgodnych z rzeczywistością. Można jednak sprawdzić w jakich
warunkach symulacje będą wykonywane najdokładniej.

\newpage
\section{Wykorzystane technologie.}
W projekcie zostały wykorzystana następujące technologie:

\subsection{Android OS}
Bazujący na jądrze Linux, system operacyjny zaprojektowany z myślą o
urządzeniach mobilnych z ekranami dotykowymi, takimi jak smartfony i tablety.
Początkowo tworzony przez Android Inc., później prawa do niego zostały wykupione
przez firmę Google. Kod źródłowy systemu jest ogólnodostępny na licencji Apache. 
Obecnie jest to najpopularniejszy system operacyjny na urządzenia mobilne.
Standardowo jest on instalowany na urządzeniach takich firm jak HTC, Motorola,
Samsung czy Sony Ericsson. Za sprawą wsparcia community, powstaje coraz większa
ilość aplikacji, które są dystrybuowane za pośrednictwem uruchomionej przez
Google usługi Google Play (odpowiednik App Marketu na urządzenia firmy Apple).

\subsection{Android SDK}
Android Software Development Kit to zestaw narzędzi deweloperskich służących do
tworzenia Aplikacji na platformę Android. W jego skład wchodzą debugger,
biblioteki, emulator oparty na QEMU, dokumentacja, przykłądowy kod oraz
tutoriale. Obecnie wspierane platformy to Linux, Mac OS X 10.5.8 lub nowszy,
Windows XP lub nowszy. Oficjalnym wspieranym środowiskiem programistycznym jest
Eclipse za pośrednictwem wtyczki ADT (\emph{Android Developers' Tolls}).
Aplikacje są zwykle pisane w języku Java, jednakże Android nie posiada oficjalnej
implementacji JVM. Zamiast tego na potrzeby systemu powstała specjalna
wirtualna maszyna - Dalvik, która została zprojektowana z myślą o większej
oszczędności energii, czasu procesora i pamięci.

\subsection{Silnik fizyczny Bullet}
Bullet Physics jest obecnie najpopularniejszym darmowym, wysokowydajnościowym
silnikiem fizycznym z otwartym źródłem. Jest szeroko wykorzystywany w grach
wideo (m in. ``Grand Theft Auto 4'', ``Red Dead Redemption''$ ^{L6} $) jak i
mimo bycia sklasyfikowanym jako wysokowydajnościowy silnik, również w
kinematografii (``Shrek"$ ^{L2} $, ``Sherlock Holmes"$ ^{L3} $). Bullet jest
również domyślnie używanym silnikiem fizycznym ta takich projektach jak program
graficzny Blender$ ^{L4} $ czy silnik gier 3d OGRE$ ^{L5} $.

\subsection{Android NDK}
Biblioteki napisane w kodzie natywnym (C/C++) mogą być kompilowane na platformę
ARM lub x86 i zainstalowane na urządzeniu używająć Android NDK (\emph{Native
Development Kit}). Natywne biblioteki mogą być uruchomione przez maszynę
wirtualną Dalvik używając metody \emph{System.LoadLibrary}. W przeciwieństwie do
Android SDK, który bazuje na pluginach do Eclipsa, NDK jest zestawem narzędzi
wywoływanych z wiersza polecenia. Każde zbudowanie projektu musi więc odbyć się
ręcznie. Możliwe jest jednak skonfigurowanie środowiska Eclipse aby kod natywny
był kompilowany automatycznie podczas kompilacji całego projektu (zostało to
opisane w sekcji \ref{sec:autoNDK}). Dostęp do natywnych funkcji z poziomu
języka Java otrzymuje się poprzez JNI (\emph{Java Native Interface}). W tym
projekcie Android NDK będzie wykorzystane do kompilacji kodu biblioteki Bullet
na platformę ARM, oraz wywoływanie jej funkcji przez integrację z kodem
napisanym w języku Java.

\subsection{OpenGL ES}
To podzbiór graficznego API - OpenGL. Zostało zaprojektowane specjalnie na
potrzeby mobilnych urządzeń.

\newpage
\section{Podstawowe koncepcje silników fizycznych.}
Ponieważ silniki fizyczne są jedynie symulacją, nie można za ich pomocą dokonać
dokładnego odwzorowania rzeczywistości. Dlatego w ich rozwiązaniach użyto
rozmaitych uproszczeń. W tej sekcji zostaną wymienione niektóre z nich.

\subsection{Wykrywanie kolizji}
Podstawowoym problemem każdego silnika fizycznego jest wykrywanie kolizji między
dwoma obiektami. Do tego celu powstało kilka różnych technik.

\subsubsection{Kształty proste (bounding box)}
Metoda polega na wpisaniu porównywanego obiektu w najprostszą do sprawdzenia
kolizji bryłę, jak kula czy prostopadłościan. Zbadanie wystąpienia kolizji
między dwoma obiektami ogranicza się wtedy do sprawdzenia kilku prostych
warunków (jak np. dla kul sprawdzenie czy odległość między środkami jest
mniejsza od sumy ich promieni). Metoda ta choć szybka ma bardzo niską
dokładność. Udoskonaleniem tej techniki może być użycie kilku prostych kształtów
do opisania jednego obiektu.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./img/boundingBox.jpg}
\caption{Skomplikowana bryła wpisana w kształt prosty$ ^{L8} $.}
\label{fig:bbox}
\end{figure}

\subsubsection{Otoczka wypłukła (convex hull)}
Większość wysokowydajnościowych silników fizycznych operuje na modelach
złożonych z wielokątów (\emph{polygons}). Badając kolizje każdego z nich między
dwoma obiektami w takim przypadku to najdokładniejsza technika, jednak również
najbardziej czasochłonna. Opracowanie techniki zminiejszającej ilość wielokątów
przy zachowaniu ogólnego kształtu bryły początkowej pozwoliłoby na znaczne
przyspieszenie obliczeń. Do tego celu w silnikach fizycznych posłużono się
pojęciem w matematyce zwanym otoczką wypłukłą. \\
Otoczka wypłukła jest definiowana jako najmnieszy spójny zbiór punktów
zawieracjący wszyskie punkty z danego zbioru P. Jednocześnie każdy odicnek
poprowadzony między dwoma dowolnymi punktami ze zbioru P zawiera się również w
otoczce wypłukłej (definicja wypłukłości). Stworzony przy pomocy tego działania
model o zredukowanej ilości wielokątów jest używany do wykrycia kolizji
poszczególnych wielokątów zamiast modelu używanego do wyświetlania. Użycie tej
metody znacznie przyśpiesza obliczenia przy zachowaniu większej dokładności od
metody kształtów prostych. Dokładnośc ta jest jednak wciąż ograniczona. Na
przykład wystrzelony pocisk nie będzie mógł przelecieć przez ucho kubka,
ponieważ dziura w kubku również wchodzi w skład bryły otoczki.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./img/convexhull.png}
\caption{Przykład wyodrębnienia otoczki wypłukłej dla dwuwymiarowego zbioru
punktów$ ^{L9} $.}
\label{fig:convexhull}
\end{figure}

\subsubsection{Metoda elementów skończonych}
Odmiennym podejściem do testowania kolizji poszczególnych wielokątów i
stosowania otoczek wypłukłych stanowi użycie metody elementów skończonych.
Metoda ta jest bardziej zaawanasowanym przypadkiem wariantu z użyciem kształtów
prostych. Obiekt zostaje podzielony na wiele elementów o określonych wcześniej
kształtach. Dzięki temu w odróżnieniu od omówionych wcześniej metod możliwe jest
symulowanie oddziaływań również we wnętrzu rozpatrywanych obiektów, a nie tylko
na ich powierzchni. Co więcej, elementy z których zbudowane jest rozpatrywane
ciało mogą być również charakteryzowane szeregiem odrębnych właściwych dla
siebie parametrów (jak temperatura). Elementy te mogą również się przemieszczać
względem siebie zgodnie z zasadami odkształcenia, dzięki czemu symulowane ciała
nie ograniczają się tylko brył sztywnych jak miało to miejsce w poprzednich
metodach. Niestety, ze względu na znacznie większe zapotrzebowanie na moc
obliczeniową, metoda ta jest wykorzystywana niemal wyłącznie w silnikach
wysokoprecyzyjnych. Silniki wysokowydajnościowe jak Bullet i Havok wykorzystują
również uproszczony wariant tej metody do symulacji zachowań ciał miękkich i płynów.

\begin{figure}[H]
\centering
\includegraphics[scale=1]{./img/finiteElementApplication.jpg}
\caption{Przykład zastosowania metody elementów skończonych dla symulacji
rozbijającego się samochodu$ ^{L10} $.}
\label{fig:finiteElementApplication}
\end{figure}

\subsubsection{Wykrywanie kolizji w silniku Bullet}
W silniku Bullet wykrywanie kolizji odbywa się dwufazowo. Każde przetwarzanie
ramki zaczyna się od ``fazy szerokiej'' (\emph{broadphase}), analizując po kolei
wszystkie możliwe pary jakie mogą dokonać zderzenia metodą kształtów prostych.
Następnie każda z par która przeszła poprzedni test jest analizowana przez
dyspozytor (\emph{dispatcher}) pod względem zderzenia odpowiednim algorytmem (w
zależności od tego czy np. rozpatrywane jest zderzenie bryły zdefinowanej przez
otoczkę wypłukłą czy kształt prosty). W omawianym projekcie zastosowane są
tylko obiekty korzystające z kształtów prostych.

\subsection{Progi ruchu}
W prawdziwym świecie zasady fizyki są zawsze aktywne. Nawet w ciałach
pozostających w spoczynku ich cząstki poruszają się na wskutek ruchów Browna.
Dla wysokowydajnościowego silnika fizycznego taka ciągła bezwarunkowa analiza
ruchu jest niepotrzebnym zużyciem mocy obliczeniowej procesora, co może
doprowadzić do spadku płynności animacji. Dlatego silniki te mogą ``zamrozić''
dane ciało (nie wykonywać obliczeń związanych z jego ruchem) jeśli wartość jego
prędkości nie przekracza określonego progu - zwanego progiem
ruchu (\emph{motion threshold}). Dane ciało może zostać ``odmrożone'' jeśli
zostanie zmuszone do ruchu przez inne ciało lub siłę. W silniku fizycznym Bullet
istnieje możliwość ustalenia wartości progu ruchu indywidualnie dla każdego
ciała.

%\subsection{Oddziaływania dynamiczne}
%\emph{TODO: penalty methods, constraints(warunki), impulses}

\newpage
\section{Wykorzystanie Android NDK jako obudowania dla silnika
Bullet} \label{sec:NDKuse}
Aby ułatwić tworzenie testowych scen zostało stworzone obudowanie obiektów
pozwalające korzystać z możliwości sinika Bullet z poziomu języka Java. Dzięki
temu proces tworzenia scen testowych zostaje skrócony oraz możliwe jest
debugowanie kodu w Eclipse IDE.

\subsection{Konfiguracja Android NDK w środowisku Eclipse}\label{sec:autoNDK}
% [source]http://mhandroid.wordpress.com/2011/01/23/using-eclipse-for-android-cc-development/
Ponieważ w przeciwieństwie do Android SDK, dla NDK nie istnieje żadna
oficjalna wtyczka automatyzująca kompilację natywnych bibliotek konieczna jest
kompilacja ręczna z wiersza poleceń. Możliwe jest jednak skonfigurowanie
środowiska Eclipse w celu integracji z NDK.
  
Aby utworzyć projekt Androida z
możliwością edycji i kompilacji bibliotek natywnych należy: \\

1. Zainstalować środowisko Eclipse (i doinstalować do niego wtyczkę
\emph{ADT}).\\

2. Pobrać kolejno \emph{Android SDK} i \emph{NDK}. W celu ułatwienia edycji
plików żródłowych w języku C++ warto również zainstalować wtyczkę 
\emph{CDT}(\emph{C++ Development Tools}) (rysunek \ref{fig:CDTinstall}).
Potrzebny będzie rónież kod żródłowy biblioteki Bullet. Dodatki w eclipse
instaluje się przez Help $ \rightarrow $ Install new software\ldots , wpisując adres
\emph{http://download.eclipse.org/releases/galileo} (lub zamisat galileo wpisać
nazwę swojej wersji Eclipse).\\
\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./img/CDT.png}
\caption{Instalacja wtyczki CDT w środowisku Eclipse.}
\label{fig:CDTinstall}
\end{figure}

3. Utworzyć nowy standardowy projekt aplikacji na system Android.\\

4. Do projektu dodać folder \emph{jni} gdzie przechowywany będzie kod źródłowy
w języku C++. Skopiować do niego foldery z kodu źródłowego biblioteki
Bullet (będą potrzebne biblioteki \emph{BulletCollision},
\emph{BulletDynamics} i \emph{LinearMath}, a także pliki \emph{btBulletCollisionCommon.h},
\emph{btBulletDynamicsCommon.h}, \emph{Bullet-C-Api.h}). Zostało to
zaprezentowane na rysunku \ref{fig:FolderTree}.\\

\begin{figure}[h]
\centering
\includegraphics[scale=1]{./img/bulletFoldery.png}
\caption{Struktura folderów do utworzenia w projekcie.}
\label{fig:FolderTree}
\end{figure}
\newpage
5. Umieścić w folderze plik \emph{Android.mk} . Zawiera on informacje jak
powinien być zbudowany projekt w kodzie natywnym. Do tego pliku należy
dodać informacje o plikach źródłowych biblioteki Bullet. Zawartość pliku
\emph{Android.mk} znajduje się w załączniku \ref{att:Androidmk}.\\

6. Przekonwertować projekt java na java/C++ , przez menu File $ \rightarrow $
New $ \rightarrow $ Other\ldots (rysunek \ref{fig:AndroidConversion})\\
  
7. We właściwościach (\emph{properties}) projektu ustawić budowanie kodu w C++
przez \emph{ndk-build}.
Najlepiej miejsce rozpakowania \emph{Android NDK} przypisać pod zmienną
środowiskową (np. \$ \{NDKROOT\}), co ułatwi przenośność projektu (rysunek
\ref{fig:EnvVariable}). W zakładce behavior należy odznaczyć opcję \emph{Clean}
i usunąć tekst z pola \emph{Build}.\\

\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{./img/properties.png}
\caption{Ustawienie zmiennej środowiskowej.}
\label{fig:EnvVariable}
\end{figure}

\newpage
\begin{figure}[H]
\centering
\includegraphics[scale=1]{./img/convert.png}
\caption{Konwersja projektu Android na projeckt C/C++.}
\label{fig:AndroidConversion}
\end{figure}

8. W C++ General $ \rightarrow $ Paths And Symbols dodać ścieżkę dla
nagłówków.\\
 
9. Ponieważ w projekcie będą wykorzystywane elementy biblioteki STL,
konieczne jest dodanie odpowiedniej ścieżki (rysunek \ref{fig:StlPath}).\\

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{./img/ndkroot.png}
\caption{Dodanie ścieżki do biblioteki STL.}
\label{fig:StlPath}
\end{figure}
  
Dodać również należy informację o wykorzystaniu STL w pliku
\emph{Application.mk}(który również muisi być dodany do projektu).
  
\lstinputlisting[language=make, caption=Zawartość pliku Application.mk,
label=andMake]{./listings/Application.mk}
  
Po tych czynnościach można edytować projekt ze składnią Javy jak i C++,
korzystając z autouzupełniania i jednolitej kompilacji. Należy jednak
pamiętać, że przy dodawaniu nowego pliku z kodem źródłowym w C++ do folderu
\emph{jni} konieczne jest umieszczenie o nim informacji w \emph{Android.mk} .

\subsection{Wywoływanie funkcji natywnych z poziomu Javy}
Do wywoływania funkcji natywnych z poziomu języka Java Android NDK wykorzystuje
interfejs JNI. Aby dodać w kodzie C/C++ funkcję możliwą do wywałania z
wirtualnej maszyny Dalvik, w kodzie w języku Java należy użyć słowa kluczowego
\emph{native}.

\lstinputlisting[language=java, linerange={1-2, 9-9, 25-25}, caption=Użycie
słowa kluczowego native w języku Java, label=lis:javaNative]{./listings/CollisionShape.java}

Następnie w kodzie natywnym zaimplementować zarejestrowaną metodę przy pomocy
nazewnictwa
Java\_$<$nazwa\_paczki$>$\_$<$nazwa\_obiektu$>$\_$<$nazwa\_metody$>$, oraz
makra JNIEXPORT. Funkcja taka posiada dwa stałe argumenty. Pierwszym argumentem
funkcji jest wskaźnik na zmienną typu \emph{JNIEnv}, która jest interfejsem
środowiska uruchomieniowego Javy. Drugim jest zmienna typu \emph{jobject}
zawierająca referencję do obiektu wywołującego daną metodę.

\newpage
\lstinputlisting[language=c++, linerange={3-4, 21-22}, caption=Implementacja
natywnej metody w kodzie c++,
label=lis:cppNative]{./listings/CollisionShape.cpp}

W kodzie nie może również zabraknąć odniesienia do pliku \emph{jni.h}.

\begin{lstlisting}[language=c++, caption=Użycie pliku nagłówkowego]
#include <jni.h>
\end{lstlisting}

\subsection{Kontener obiektów}
Ponieważ niemożliwy jest bezpośredni dostęp do obiektów po stronie natywnej,
w tym projekcie zostają zastosowane obiekty obudowujące. Po stronie Javy każdy
obiekt posiada unikalny identyfikator, który zostaje mu nadany przez
konstruktor w momencie jego tworzenia.

\lstinputlisting[language=java, linerange={5-6, 9-9, 26-31}, caption=Tworzenie
nowego obiektu obudowującego,
label=lis:javaGenId]{./listings/DynamicsWorld.java}

W kodzie natywnym wszystkie identyfikatory są przechowywane w mapie
\emph{pointer\_map} z biblioteki STL. Za jej pomocą kojarzone są identyfikatory
obudowujących obiektów Javy z obiektami biblioteki Bullet.

\newpage
\lstinputlisting[language=c++, caption=Zawartość pliku btObjects.h\,
zawierającego mapę, label=lis:btObjects_h]{./listings/btObjects.h}

Funkcje \emph{put} i \emph{get} służą do umieszczania i pobierania obiektów
biblioteki Bullet z mapy.

\lstinputlisting[language=c++, caption=Zawartość pliku btObjects.cpp\,
implementującego kontener identyfikatorów,
label=lis:btObjects_h]{./listings/btObjects.cpp}

Z każdym wywołaniem metody \emph{put} zostaje zwiększony licznik
\emph{pointer\_map\_count}(ln. 10) dzięki czemu każy obiekt dodany do mapy
posiada unikalny identyfikator.\\
Następnie w implementacji metody \emph{constructor} przy
pomocy funkcji \emph{put} zostaje nadany nowy identyfikator i
przekazany (zwrócony) obiektowi obudowującemu z listingu \ref{lis:javaGenId}.

\begin{lstlisting}[language=c++, caption=Użycie mapy pointer\_map w
funkcji constructor.]
extern "C"
{
	JNIEXPORT jint Java_org_bulletSamples_physics_DynamicsWorld_constructor( JNIEnv* env, jobject self )
	{
		//inicjalizacja skladowych obiektow btDiscreteDynamicsWorld
		btDiscreteDynamicsWorld* dynamicsWorld = new
		btDiscreteDynamicsWorld(dispatcher,broadphase,solver,collisionConfiguration);
		return btObjects::put(dynamicsWorld);
	}
}
\end{lstlisting}

Aby uzyskać dostęp do przechowywanego przez mapę obiektu należy użyć metody
\emph{get}, przekazując jej otrzymaną przez parametr wartość \emph{id}. Ponieważ
mapa kojarzy identyfikatory ze wskaźnikami typu \emph{void*}, pobrana wartość
musi być przerzutowana na odpowiedni typ.

\begin{lstlisting}[language=c++, caption=Pobranie przechowywanego obiektu z
mapy] extern "C"
{
	JNIEXPORT void Java_org_bulletSamples_physics_DynamicsWorld_NCreateBox( JNIEnv* env, jobject self, jint id ...) 
	 {
	 	btDiscreteDynamicsWorld* dw = (btDiscreteDynamicsWorld*)btObjects::get(id);
	 	//wykonywanie operacji na pobranym obiekcie
	}
}
\end{lstlisting}

Diagram opisujący całą sekwencję tworzenia i wykonywania akcji na
obiektach przedstawiono na rysunku \ref{fig:DiagWrapper}.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{./img/sequenceDiagram.png}
\caption{Diagram przedstawiający sekwencje czynności wykonywanych na obiektach
opakowujących.}
\label{fig:DiagWrapper}
\end{figure}

\newpage
\subsection{Struktura biblioteki obudowującej}
W celu ułatwienia składania scen testowych część klas biblioteki Bullet została
opakowana w klasach języka Java. Strukturę zawierającej je paczki przedstawia
rysunek \ref{fig:DiagStructure}.
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{./img/packageDiagram.png}
\caption{Diagram przedstawiający strukturę klas opakowujących.}
\label{fig:DiagStructure}
\end{figure}

\subsubsection{Typy geometryczne}
Poza klasami odpowiadającymi za podstawową geometrię jak wektor (\emph{Vector3})
i kwaternion (\emph{Quaternion}), paczka \emph{org.bulletTest.geometry} zawiera
również klasy definiujące kształty - prostopadłościan (\emph{Box}) i
kulę(\emph{Sphere}). Klasy \emph{Box} i \emph{Sphere} posiadają
odpowiednie metody pozwalające na renderowanie określonych kształtów
o podanych rozmiarach.

\newpage
\subsubsection{Typy fizyczne}
Dostępne metody obiektów opakowujących klasy silnika Bullet zostały
przedstawione poniżej.

\paragraph{DynamicsWorld}
Klasa przedstawia środowisko fizyczne. Dodawane są do niego symulowane bryły
sztywne i sprężyny. Struktura klasy została przedstawiona w tabeli \ref{tab:DynamicsWorld}.\\
\begin{table}[H]
\input{./tab/DynamicsWorld.tex}
\caption{Struktura klasy DynamicsWorld.}
\label{tab:DynamicsWorld}
\end{table}

\newpage
\paragraph{CollisionShape}
Klasa przedstawia symulowane obiekty brył sztywnych. Struktura została
przedstawiona w tabeli \ref{tab:CollisionShape}\\

\begin{table}[H]
\input{./tab/CollisionShape.tex}
\caption{Struktura klasy CollisionShape.}
\label{tab:CollisionShape}
\end{table}

\paragraph{Spring}\label{sec:spring}
Klasa przedstawia symulowane obiekty ciał sprężystych.\\
W parametrach funkcji można znaleźć typ enumeracyjny \emph{DoF} -
stopnie swobody (\emph{degrees of freedom}). Określają one do jakiego stopnia
swobody odnosi się dane wywołanie metody. Dostępne wartości przedstawia tablea
\ref{tab:dof}.\\

\begin{table}[H]
\input{./tab/DoF.tex}
\caption{Dostępne wartości dla struktury DoF.}
\label{tab:dof}
\end{table}

Do zaobrazowania znaczenia poszczególnych parametrów funkcji klasy Spring
zostanie wykorzystana poniższa scena:\\

\lstinputlisting[language=java, caption=Scena demonstrująca użycie klasy Spring,
label=lis:spring_demo]{./listings/spring_demo.java}

\begin{figure}
\centering
\includegraphics[scale = 0.6]{./img/Spring-render.png}
\caption{Render sceny z listingu \ref{lis:spring_demo}.}
\label{fig:spring_demo}
\end{figure}

Opisy metod w tabeli \ref{tab:Spring} odnoszą się do oznaczeń na rysunku
\ref{fig:spring_demo}. Wszystkie metody działąjące na stopień swobody sprężyny
odnoszą się do ciała oznaczonego przez \textbf{B}.\\

\begin{table}
\input{./tab/Spring.tex}
\caption{Struktura klasy Spring.}
\label{tab:Spring}
\end{table}

\subsection{Przekazywanie argumentów i zwracanych wartości}
Podczas wymiany argumentów przez funkcje między wirtualną maszyną Javy a kodem
natywnym podstawowe typy danych (jak \emph{int} czy \emph{float}) zostają
przekonwertowane przez interfejs JNI na im odpowiadające dla danego środowiska.
Natomiast gdy przekazywane są typy złożone (jak \emph{Vector3} i
\emph{Quaternion} w bibliotece \emph{org.bulletTest.geometry}), wartości
otrzymywane w parametrach to referencje na dany obiekt. W takich przypadkach
konwersja musi być wykonana przez kod aplikacji poprzez pobranie i odpowiednie
przypisanie pól z typami podstawowymi. Poniższy listing przedstawia metodę
zamieniającą obiekt Javy \emph{Vector3} na natywny obiekt klasy \emph{btVector3}
z biblioteki Bullet.

\lstinputlisting[language=c++, caption=Konwersja klasy Vector3 z obiektu Javy
do obiektu natywnego., label=lis:jnVector3Conv,
linerange={39-50}]{./listings/common.cpp}

Parametr \emph{env} to referencja do środowiska uruchomieniowego Javy,
\emph{obj} jest referencją na obiekt Javy \emph{Vector3}, a \emph{vec} to
zwrócony przekonwertowany obiekt \emph{btVector3}. Przy pomocy metody
\emph{GetObjectlClass} (ln. 3) zostaje pobrana zmienna reprezentująca klasę
obiektu \emph{obj}, która zostaje wykorzystana przez metody
\emph{GetFieldId} (ln. 4-6) do pobrania reprezentacji pól obiektu. Następnie za
ich pomocą wyciągnięte zostają same wartości pól - współrzędnych \emph{x},
\emph{y} i \emph{z} wektora (ln. 8-10), które zostają wykorzystane do stworzenia
nowego obiektu natywnego klasy \emph{btVector3}. Analogicznie realizowana jest
konwersja obiektów natywnych na obiekty Javy.

\subsection{Zwalnianie pamięci}
Gdy dany opakowujący klasę biblioteki Bullet obiekt, przestaje być potrzebny,
należy zwolnić zajmowaną przez niego pamięć. Niestety, wbudowany w maszynę
wirtualną Dalvik odśmiecacz pamięci (\emph{garbage collector}) nie może usunąć
obiektu natywnego. Do tego celu wymagane jest zaimplementowanie destruktora dla
klasy opakowującej. Pierwszym krokiem jest przeciążenie metody \emph{finalize}
wywoływanej podczas usuwania obiektu Javy przez odśmiecacz.

\begin{lstlisting}[language=Java, caption=Przeciążenie metody \emph{finalize}
na przykładzie klasy \emph{DynamicsWorld}] public class DynamicsWorld
{
	...
	native private void destructor(int id);
	...
	protected void finalize() throws Throwable
	{
		destructor(id);
		super.finalize();
	}
	...
}
\end{lstlisting}

Następnie należy zaimplementować funkcję destruktora w kodzie natywnym.

\begin{lstlisting}[language=c++, caption=Implementacja funkcji
\emph{destructor} na przykładzie klasy \emph{DynamicsWorld}]
JNIEXPORT void Java_org_bulletSamples_physics_DynamicsWorld_destructor( JNIEnv* env, jobject self, jint id )
{
	delete (btDiscreteDynamicsWorld*)btObjects::get(id);
	btObjects::remove(id);
}
\end{lstlisting}

W linijce 3 pobierany jest wskaźnik na obiekt typu
\emph{btDiscreteDynamicsWorld}, a następnie wskazywany przez niego obiekt jest
usuwany za pomocą polecenia \emph{delete}. W linijce 4 usuwany jest
identyfikator wraz z wskaźnikiem na nieistniejący już obiekt z mapy
\emph{btObjects}.

\newpage
\subsection{Sceny}
W celu ułatwienia dodawania kolejnych testów silnika powstał mechanizm scen,
które można wymieniać przed kompilacją aplikacji. Każda scena zawiera właściwe
dla siebie obiekty fizyczne i związane z nimi instrukcje. Klasa \emph{BaseScene}
jest klasą bazową dla wszystkich scen w projekcie.

\begin{figure}[H]
\centering
\includegraphics[scale=0.6]{./img/SceneClassDiagram.png}
\caption{Diagram reprezentujący klasę SomeScene.}
\label{fig:sceneClassDiagram}
\end{figure}

Każda scena posiada własny egzemplarz klasy \emph{DynamicsWorld} nadawany jej
przez konstruktor. Przeciążając metody \emph{create}, \emph{update} i
\emph{render} można na scenie wykonać każdą akcję.

\newpage
\section{Implementacja i zastosowanie dodatkowych możliwośći silnika
Bullet}\label{sec:dod}
W tej części pracy zostanie opisany przebieg implementacji
dodatkowych funkcji wykorzystujących możliwości oferowane przez platformy
mobilne i silnik Bullet.
%\emph{TODO:
%w jaki sposób zostały zaimplementowane pozostałe przydatne mechanizmy silnika i
%jak zostały wykorzystane możliwości smartphone'a do uatrakcyjnienia
% aplikacji:)}

\subsection{Akcelerometr}
%http://developer.android.com/guide/topics/sensors/sensors_overview.html
Większość smartfonów i tabletów obecnej generacji wyposażona jest w
akcelerometr. Urządzenie to może być wykorzystane na przykład do sterowania
kierunkiem przyspieszenia grawitacyjnego lub kątem ustawienia kamery w
symulacji.

Na początku należy stworzyć statyczną klasę przechowującą pobrany wektor
przyspieszenia z akcelerometru.

\begin{lstlisting}[language=java, caption=Klasa Accelerometer przechowująca
dane pobrane z akcelerometru.]
package org.bulletSamples;
 
import org.bulletSamples.geometry.Vector3;
 
public class Accelerometer
{
	public static Vector3 gravity = new Vector3();
}
\end{lstlisting}

W systemie Android dostęp do akcelerometru uzyskuje się poprzez statyczną klasę
\emph{SensorManager}.

\begin{lstlisting}[language=java, caption=Pobranie wektora przyspieszenia z
akcelerometru.] public class BulletTestActivity extends Activity implements SensorEventListener {

	public void onCreate(Bundle savedInstanceState) {
		...
		mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);
		mAccelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_GRAVITY);
    }
    
	...
    
    public void onSensorChanged(SensorEvent event) {
		Accelerometer.gravity.x = event.values[0];
		Accelerometer.gravity.y = event.values[1];
		Accelerometer.gravity.z = event.values[2];
	}
}
\end{lstlisting}

Główne \emph{activity} aplikacji musi implementować interfejs
\emph{SensorEventListener}. 

Każda oś wektora \emph{Accelerometer}.\emph{gravity} odpowiada osi nachylania
urządrzenia na którym uruchomiona jest aplikacja. Rozkład tych osi
zaprezentowano na rysunku \ref{fig:axis_device}.

\begin{figure}[H]
\centering
\includegraphics[scale = 0.6]{./img/axis_device.png}
\caption{Rozłożenie osi wektora przyspieszenia dla akcelerometru w urządzeniu
z systemem Android$ ^{L7} $.}
\label{fig:axis_device}
\end{figure}

Tak pobrane wartości wektora akcelerometru można wykorzystać do sterowania
przyspieszeniem grawitacji aplikacji. W tym celu we fragmencie odpowiedzialnym
za rendering sceny można umieścić odpowiedni kod.

\begin{lstlisting}[language=java, caption=Sterowanie wektorem przyspieszenia
ziemskiego przy pomocy akcelerometru]import org.bulletSamples.Accelerometer;
import org.bulletSamples.geometry.*;
import org.bulletSamples.physics.*;

public class SomeScene extends BaseScene {
	...
	
	public void render(GL10 gl)
	{
		dw.setGravity(Accelerometer.gravity);
		//kod odpowiedzialny za rendering obiektow na scenie
	}
}
\end{lstlisting}

Akcelerometr można również zastosować do sterowania innymi parametrami jak na
przykład kątem nachylenia kamery.

\newpage
\begin{lstlisting}[language=java, caption=Sterowanie kątem nachylenia kamery
przy pomocy akcelerometru, label=lis:accCamera]import org.bulletSamples.Accelerometer;
import org.bulletSamples.geometry.*;
import org.bulletSamples.physics.*;

public class SomeScene extends BaseScene {
	...
	
	public void render(GL10 gl)
	{
		Camera.active.position = Accelerometer.gravity.normalize().multiply(60);
		//kod odpowiedzialny za rendering obiektow na scenie
	}
}
\end{lstlisting}

Na listingu \ref{lis:accCamera} w linijce 21 zastosowano wektor pobrany z
akcelerometru i pomnożony przez skalar 60 jako wektor pozycji dla kamery na
scenie.

\subsection{Metoda przeciągnij i upuść}\label{sec:dragAndDrop}
Inną możliwością wprowadzenia interakcji w aplikacji jest wykorzystanie ekranu
dotykowego dostępnego w większości produkowanych dziś urządzeń mobilnych.
Możliwe jest dzięki temu wprowadzenie funkcji ``przeciągnij i upuść''
(\emph{drag and drop}), dzięki czemu możliwe będzie złapanie dowolnego obiektu
fizycznego i przeniesienie go w inne miejsce palcem po ekranie.

Pierwszym krokiem jest zamiana współrzędnych ekranu (miejsca w którym ekran
został dotkniętuy palcem) na współrzędne świata silnika fizycznego. Proces ten
został przedstawiony na rysunku \ref{fig:raycast}.

\begin{figure}
\centering
\includegraphics[scale = 0.8]{./img/Rzutowanie.png}
\caption{Rzutowanie współrzędnych ekranu na współrzędne świata silnika}
\label{fig:raycast}
\end{figure}

Następnie zostaje poprowadzona linia (\emph{raycast}) od ``oka'' do
przerzutowanego punktu we spółrzędnych silnika (na rysunku
oznaczonego przez \textbf{p}). ``Podniesiony'' zostaje obiekt przecinający się z
poprowadzoną linią (obiekt \textbf{O}).

Zamianę współrzędnych należy zacząć od zmiany układu współrzędnych. W
urządzeniach z systemem Android przebieg osi oznaczono na rysunku
\ref{fig:raycast} czerwonymi strzałkami. W silniku fizycznym osie oznaczono
żółtą i zieloną linią. Odpowiednie przekształcenie dokonywane jest przez macierz
ze wzoru \ref{eq:srodek}.

\begin{equation}p_{t} = 
p_{e}
\begin{bmatrix}1&0&0&0\\0&-1&0&0\\0&0&1&0\\-w_{e}&h_{e}&0&1\end{bmatrix}
\label{eq:srodek}
\end{equation}

Gdzie:\\
$ p_{t} = \begin{bmatrix}x_{t}&y_{t}&0&1\end{bmatrix} $ to przetransportowany
wektor punktu\\
$ p_{e} = \begin{bmatrix}x_{e}&y_{e}&0&1\end{bmatrix} $ to wektor pobranych
współrzędnych ekranowych\\
$ w_{e} $ i $ h_{e} $ to kolejno połowa szerokości i wysokości ekranu urządzenia
w pikselach
\\ \\
Następnie należy dokonać przeskalowania pobranych współrzędnych aby były one
zgodne ze skalą płaszczyzny rzutowania (płaszczyzny na której znajduje się
punkt \textbf{p} z rysunku \ref{fig:raycast}). Przekształcenie to jest
dokonywane przez następującą zależność:

\begin{equation}
\frac{y_{t}}{h_{e}}=\frac{y_{p}}{h_{p}}
\label{eq:przeksz}
\end{equation}

Gdzie:\\
$ y_{p} $ to przetransformowana współrzędna na płaszczyźnie rzutowania\\
$ h_{p} $ to wysokość płaszczyzny rzutowania oznaczona na rysunku
\ref{fig:raycast} przez \textbf{h}\\
Wysokość płaszczyzny rzutowania jest zależna od \emph{FoV} (\emph{field of
view}) - kąta pola widzenia i może być obliczona w następujący sposób:

\begin{equation}
h_{p} = f \tg \alpha
\label{eq:alpha}
\end{equation}
\emph{f} to odległość ``oka'' od płaszczyzny rzutowania (na rysunku oznaczona
niebieską linią)\\
$ \alpha $ to połowa kąta \emph{FoV}. Ponieważ obliczaną wysokością jest połowa
wysokości płaszczyzny rzutowania, w tym miejscu zostaje zastosowana połowa
kąta.\\
\\
Korzystając ze wzorów \ref{eq:przeksz} i \ref{eq:alpha} otrzymuje się zależność:

\begin{equation}
y_{p} = \frac{fy_{t} \tg \alpha}{h_{e}}
\end{equation}

W celu zachowania proporcji generowanego obrazu współrzędna o mniejszej
maksymalnej wartości przekształcona zostaje jak współrzędna o większej
maksymalnej wartości. Na potrzeby tych obliczeń przyjęte zostaje, że $ w_{e} <
h_{e} $, czyli wartość \emph{x} zostaje obliczana jak wartość \emph{y}.
Omawiane przeskalowanie zostaje wykonane przez poniższą macierz:

\begin{equation}
\begin{bmatrix}\frac{f \tg \alpha}{h_{e}}&0&0&0\\0&\frac{f \tg \alpha}{h_{e}}&0&0\\0&0&1&0\\0&0&p&1\end{bmatrix}
\label{eq:scale}
\end{equation}

Mnożąc macierze \ref{eq:srodek} i \ref{eq:scale} otrzymana zostaje macierz
rzutowania punktu z współrzędnych ekranowych na współrzędne silnika fizycznego:

\begin{equation}
S = 
\begin{bmatrix}1&0&0&0\\0&-1&0&0\\0&0&1&0\\-w_{e}&h_{e}&0&1\end{bmatrix}
\begin{bmatrix}\frac{f \tg \alpha}{h_{e}}&0&0&0\\0&\frac{f \tg
\alpha}{h_{e}}&0&0\\0&0&1&0\\0&0&p&1\end{bmatrix} =
\begin{bmatrix}\frac{f \tg \alpha}{h_{e}}&0&0&0\\0&-\frac{f \tg
\alpha}{h_{e}}&0&0\\0&0&1&0\\-\frac{w_{e}f \tg \alpha}{h_{e}}&f \tg \alpha&p&1\end{bmatrix}
\end{equation}

Korzystając z powyższej macierzy można otrzymać współrzędne punktu do którego
zostaje poprowadzona linia ($ p_{p} $) wybierająca chwytany obiekt.

\begin{equation}
p_{p} = p_{e} S W
\label{eq:transform}
\end{equation}
Gdzie:\\
$ p_{p} $ i $ p_{e} $ to wektory postaci:\\
$ p_{p} = \begin{bmatrix}x_{p}&y_{p}&z_{e}&1\end{bmatrix} $ \\
$ p_{e} = \begin{bmatrix}x_{e}&y_{e}&0&1\end{bmatrix} $ \\
\emph{W} to macierz świata wyświetlanej sceny (iloczyn odwrotnej macierzy
translacji kamery i odwrotnego obrotu kamery).\\
\\
\newpage
Aby funkcja ``przeciągnij i upuść'' działała, konieczne jest przechwycenie przez
aplikację zdarzenia dotknięcia ekranu dotykowego urządzenia, co prezentuje
listing \ref{lis:onTouch}.

\begin{lstlisting}[language=java, caption=Przechwycenie zdarzenia
dotknięcia ekranu.,label=lis:onTouch]public void onTouch(MotionEvent e)
{
	int x = (int)e.getX();
	int y = (int)e.getY();
	int eventaction = e.getAction();
	Vector3 rayFrom;
	if(Camera.active != null) rayFrom = Camera.active.getPosition();
	else rayFrom = Vector3.zero();
    switch (eventaction ) { 
    	case MotionEvent.ACTION_DOWN:
    		dw.pickObject(rayFrom, getRayTo(x, y));
    		break;
    	case MotionEvent.ACTION_MOVE:
    		dw.dragObject(rayFrom, getRayTo(x, y));
    		break;
    	case MotionEvent.ACTION_UP:
    		dw.dropObject(rayFrom, getRayTo(x, y));
    		break;
    }
}
\end{lstlisting}

Obiket \emph{dw} jest obiektem klasy \emph{DynamicsWorld}. Funkcja
\emph{getRayTo} wykonuje operację ze wzoru \ref{eq:transform}.\\

Implementacja metody \emph{pickObject}, wywoływanej po naciśnięciu obiektu na
ekranie, wygląda następująco:

\begin{lstlisting}[language=c++, caption=Implementacja
metody pickObject,label=lis:pickObject]
JNIEXPORT void Java_org_bulletSamples_physics_DynamicsWorld_NpickObject( JNIEnv* env, jobject self, jint id, jobject jRayFrom, jobject jRayTo )
{
	btDiscreteDynamicsWorld* dw = (btDiscreteDynamicsWorld*)btObjects::get(id);
	btVector3 rayFrom, rayTo;
	jobjectToBtVector3(env, jRayFrom, rayFrom);
	jobjectToBtVector3(env, jRayTo, rayTo);
	btCollisionWorld::ClosestRayResultCallback rayCallback(rayFrom,rayTo);
	dw->rayTest(rayFrom,rayTo,rayCallback);
	if (rayCallback.hasHit())
	{
		btRigidBody* body = btRigidBody::upcast(rayCallback.m_collisionObject);
		if (body)
		{
			if (!(body->isStaticObject() || body->isKinematicObject()))
			{
				pickedBody = body;
				pickedBody->setActivationState(DISABLE_DEACTIVATION);
				btVector3 pickPos = rayCallback.m_hitPointWorld;
				btVector3 localPivot = body->getCenterOfMassTransform().inverse() * pickPos;
				btTransform tr;
				tr.setIdentity();
				tr.setOrigin(localPivot);
				btGeneric6DofConstraint* dof6 = new btGeneric6DofConstraint(*body, tr,false);
				dof6->setLinearLowerLimit(btVector3(0,0,0));
				dof6->setLinearUpperLimit(btVector3(0,0,0));
				dof6->setAngularLowerLimit(btVector3(0,0,0));
				dof6->setAngularUpperLimit(btVector3(0,0,0));
				dw->addConstraint(dof6);
				pickConstraint = dof6;
				oldPickingPos = rayTo;
				hitPos = pickPos;
				oldPickingDist  = (pickPos-rayFrom).length();
			}
		}
	}
}
\end{lstlisting}

Na początku zostaje wykonany \emph{raytest} - sprawdzenie czy obiekt nie
znajduje się na linii od \emph{rayFrom} do \emph{rayTo} (ln. 8-16). Następnie
wygenerowane zostaje ciało sprężyste (ln.23-27) łączące napotkane ciało z
punktem aktualnego zderzenia. Wiekszość wartości zostaje zapisana w wartościach
globalnych, ponieważ są potrzebne do działania pozostałych funkcji (ln.
16,29-32).

Metoda \emph{dragObject} jest wywoływana podczas przesuwania obiektu po
ekranie.

\begin{lstlisting}[language=c++, caption=Implementacja
metody dragObject,label=lis:dragObject]
JNIEXPORT void Java_org_bulletSamples_physics_DynamicsWorld_NdragObject( JNIEnv* env, jobject self, jint id, jobject jRayFrom, jobject jRayTo )
{
	if(pickConstraint == 0) return;
	btDiscreteDynamicsWorld* dw = (btDiscreteDynamicsWorld*)btObjects::get(id);
	btVector3 rayFrom, rayTo;
	jobjectToBtVector3(env, jRayFrom, rayFrom);
	jobjectToBtVector3(env, jRayTo, rayTo);
	btGeneric6DofConstraint* pickCon = static_cast<btGeneric6DofConstraint*>(pickConstraint);
	btVector3 newRayTo = rayTo;
	btVector3 oldPivotInB = pickCon->getFrameOffsetA().getOrigin();
	btVector3 newPivotB;
	btVector3 dir = newRayTo-rayFrom;
	dir.normalize();
	dir *= oldPickingDist;
	newPivotB = rayFrom + dir;
	pickCon->getFrameOffsetA().setOrigin(newPivotB);
}
\end{lstlisting}

Przechowywana sprężyna w zmiennej \emph{pickConstraint} otrzymuje nowe
współrzędne. Sa one obliczone na podstawie
wczęniej przechowanyvh wartości.

Ostatnia metoda \emph{dropObject} jest wywoływana po oderwaniu palca od
powierzchni ekranu.

\begin{lstlisting}[language=c++, caption=Implementacja
metody dropObject,label=lis:dropObject]
JNIEXPORT void Java_org_bulletSamples_physics_DynamicsWorld_NdropObject( JNIEnv* env, jobject self, jint id, jobject jRayFrom, jobject jRayTo )
{
	btDiscreteDynamicsWorld* dw = (btDiscreteDynamicsWorld*)btObjects::get(id);
	dw->removeConstraint(pickConstraint);
	delete pickConstraint;
	pickConstraint = 0;
	pickedBody->forceActivationState(ACTIVE_TAG);
	pickedBody->setDeactivationTime( 0.f );
	pickedBody = 0;
}
\end{lstlisting}

Po zaimplementowaniu powyższych funkcji w aplikacji możliwe jest przenoszenie
widocznych na ekranie obiektów.

\subsection{Linie pomocnicze}\label{sec:debugDrawer}
W celu ułatwienia projektowania symulacji można wykorzystać
wbudowaną w silniku Bullet możliwość rysowania linii pomocniczych (\emph{debug
draw}). Linie te zaznaczają między innymi limity obrotów i wielkość ramki ciała
zawieszonego na sprężynie. Rysowane linie pomocnicze można zauważyć na rysunku
\ref{fig:spring_demo}.\\
Aby możliwe było korzystanie z możliwości rysowania linii pomocniczych, należy
zaimplementować interfejs silnika Bullet \emph{btIDebugDraw}. Interfejs ten
posiada metody odpowiadające za rysowanie prostych kształtów (np. \emph{drawLine}).
\newpage Implementacja poszczególych metod pozwala na niezależne od silnika
renderującego wyświetlanie pomocniczych kształtów.

W tym przykładzie zostanie zaimplementowana metoda \emph{drawLine}.
Implementacja interfejsu w kodzie natywnym wygląda następująco:

\begin{lstlisting}[language=c++, caption=Deklaracja klasy
DebugDrawer,label=lis:debugDrawer_cpp]
class DebugDrawer : public btIDebugDraw
{
public:
	DebugDrawer();
	virtual void drawLine(const btVector3& from,const btVector3& to,const btVector3& color); 
	...
};

void DebugDrawer::drawLine(const btVector3& from,const btVector3& to,const btVector3& fromColor, const btVector3& toColor)
{
	jclass claz = globalEnv->FindClass("org/bulletSamples/physics/DebugDrawer");
	jmethodID mid = globalEnv->GetStaticMethodID(claz, "drawLine", "(Lorg/bulletSamples/geometry/Vector3;Lorg/bulletSamples/geometry/Vector3;Lorg/bulletSamples/geometry/Vector3;Lorg/bulletSamples/geometry/Vector3;)V");
	globalEnv->CallStaticVoidMethod(claz, mid, jVector3(globalEnv, from), jVector3(globalEnv, to), jVector3(globalEnv, fromColor), jVector3(globalEnv, toColor));
}
\end{lstlisting}

Metoda \emph{DebugDrawer::drawLine} odnosi sie do statycznej metody
\emph{drawLine} klasy \emph{DebugDrawer} zaimplementowanej w Javie. W linijce
11 pobrany zostaje identyfikator metody, który zostaje wykorzystany do jej
wywołania w linijce 12 , przekazując jej swoje parametry wywołania. Zmienna
\emph{globalEnv}, jest przechowywaną globalnie zmienną zawierającą wskaźnik na
środowisko uruchomieniowe Javy. Jest ona odświeżana przy każdej rysowanej
ramce. Ponieważ metoda \emph{drawLine} nie jest bezpośrednio wywoływana przez
metodę w środowisku Javy, a przez obiekt klasy \emph{DynamicsWorld}, nie ma ona
dostępu do obiektu \emph{env} przez parametr. W kodzie natywnym pobranie
zmiennej \emph{globalEnv} wygląda nstępująco:

\newpage
\begin{lstlisting}[language=c++, caption=Deklaracja
funkcji renewEnv w kodzie natywnym,label=lis:renewEnvNat]
JNIEnv* globalEnv = 0;

extern "C"
{
	JNIEXPORT void Java_org_bulletSamples_physics_DebugDrawer_renewEnv(JNIEnv* env, jclass claz)
	{
		globalEnv = env;
	}
}
\end{lstlisting}

Natomiast w kodzie Javy:

\begin{lstlisting}[language=c++, caption=Deklaracja
i wykorzystanie metody renewEnv w kodzie Javy,label=lis:renewEnvJav]
public class DebugDrawer {
	public static native void renewEnv();
	...
}

public class DynamicsWorld {
	...
	public void drawDebug(GL10 gl)
	{
		DebugDrawer.gl = gl;
		gl.glLoadIdentity();
		Camera.applyTransform(gl);
		DebugDrawer.renewEnv();
		NdrawDebug();
	}
}
\end{lstlisting}

Pobieranie globalnego obiektu \emph{env} odbywa się przy każdym odrysowywaniu
linii pomocniczych (w metodzie \emph{drawDebug} ln. 13).\\
Posiadając klasę implementującą metodę \emph{drawLine} możliwe jest przypisanie
obiektu tej klasy do obiektu klasy \emph{DebugDrawer}. Przypisanie to następuje
w konstruktorze klasy \emph{DebugDrawer}.

\newpage
\begin{lstlisting}[language=c++, caption=Przypisanie
obiektu DebugDrawer obiektowi DynamicsWorld,label=lis:DynamicsWorldConstructor]
JNIEXPORT jint Java_org_bulletSamples_physics_DynamicsWorld_constructor( JNIEnv* env, jobject self )
{
	...
    DebugDrawer* dd = new DebugDrawer;
    dd->setDebugMode(btIDebugDraw::DBG_DrawConstraints+btIDebugDraw::DBG_DrawConstraintLimits);
    dynamicsWorld->setDebugDrawer(dd);

	return btObjects::put(dynamicsWorld);
}
\end{lstlisting}

Po wprowadzeniu powyższych funkcji i zastosowaniu metody
\emph{DebugDrawer.drawDebug} w funkcji renderującej, wyświetlane są linie
pomocnicze. Jednak po kilku klatkach aplikacja przestaje działać. W rejestrze
błędów można zobaczyć:

\begin{figure}[H]
\centering
\includegraphics[scale = 0.6]{./img/logCat.PNG}
\caption{Błędy widoczne po próbie zastosowania klasy DebugDrawer.}
\label{fig:logCat}
\end{figure}

Widoczny błąd spowodowany jest przepełnieniem lokalnego bufora JNI. Podczas
przekazywania parametrów przez funkcję \emph{drawLine} z listingu
\ref{lis:debugDrawer_cpp}, obiekty przekazywane przez parametry przechowywane są
w lokalnym buforze JNI, który ma ograniczoną pojemność. Problem ten można ominąć
przez użycie tymczasowych, statycznych zmiennych przechowujących przekazywane
parametry metodzie \emph{drawLine} po stronie Javy.

\begin{lstlisting}[language=Java,
caption=Tymczasowe zmienne przechowujące
parametry wywołania metody drawLine,label=lis:dummyVals] public
class DebugDrawer
{
	...
	public static Vector3 dummy1 = Vector3.zero(), dummy2 = Vector3.zero(), dummy3 = Vector3.zero(), dummy4 = Vector3.zero(); 
	...
}
\end{lstlisting}

\newpage
Kod funkcji \emph{DebugDrawer::drawLine} z listingu \ref{lis:debugDrawer_cpp}
powinien wtedy wyglądać:

\begin{lstlisting}[language=C++,
caption=Implementacja metody drawLine
korzystającej z tymczasowych zmiennych,label=lis:drawLineDummyVals]
void DebugDrawer::drawLine(const btVector3& from,const btVector3& to,const btVector3& color)
{
	jclass claz = globalEnv->FindClass("org/bulletSamples/physics/DebugDrawer");
	jmethodID mid = globalEnv->GetStaticMethodID(claz, "drawLine", "()V");
	setNamedVector3(globalEnv, claz, "dummy1", from); setNamedVector3(globalEnv, claz, "dummy2", to); 
	setNamedVector3(globalEnv, claz, "dummy3", color);
	setNamedVector3(globalEnv, claz, "dummy4", color);
	globalEnv->CallStaticVoidMethod(claz, mid);
}
\end{lstlisting}

Po tym zabiegu możliwe jest bezbłędne renderowanie linii pomocniczych na scenie.

%\subsection{Wykrywanie kolizji}
%\emph{TODO: o możliwości logowania kolizkji wybranych obiektów}

\newpage
\section{Wykorzystanie silnika Bullet w doświadczeniach
fizycznych}\label{sec:wykorzystanie}
Do tej pory rozważane była jedynie kwestie
samego działania silnika na platformie Android. Jakie jednak niesie on możliwości pod kątem symulacji
fizycznych? Jako wysokowydajnościowy silnik, Bullet nie ma wysokiej precyzji
pomiarów, ale możliwe jest sprawdzenie w jakich warunkach wyniki symulacji są
zblizone do rzeczywistych.

\subsection{Gromadzenie pomiarów}
W celu łatwego gromadzenia danych pomiarowych w trakcie trwania testu powstała
klasa Logger przechowująca funkcje odpowiadające za przechowywanie danych w
pamięci urządzenia.
  \lstinputlisting[language=Java, caption=Klasa Logger,
  label=lis:logger]{./listings/Logger.java}
Należy również pamiętać o zezwoleniu aplikacji na manipulowanie pamięcią
zewnętrzną. Konieczny jest wpis w manifeście aplikacji.
\lstinputlisting[language=xml, caption=Zawartość pliku AndroidManifest.xml,
  label=lis:manifest,linerange={6-9}]{./listings/AndroidManifest.xml}

\subsection{Zasada zachowania energii}
Zasada zachowania energii to jedna z fundamentalnych zasad mechaniki klasycznej.
Stwierdza ona, że w układzie izolowanym suma wszystkich rodzajów energii układu
jest stała (nie zmienia się w czasie). W konsekwencji, energia w układzie
izolowanym nie może być ani utworzona, ani zniszczona, może jedynie zmienić się
jej forma.\\

\subsubsection{Rodzaje badanych energii}

\textbf{Energia kinetyczna}\\
Badanymi ciałami są bryły sztywne (\emph{rigid bodies}), więc brane
pod uwagę będą dwa rodzaje energii kinetycznej: liniowa oraz obrotowa.\\

\textbf{Liniowa energia kinetyczna}\\
Jest to energia jaką posiada ciało za sprawą bycia w ruchu. Jest zdefinowana
jako wartość pracy, jaka jest wymagana do wprowadzenia będącego w stanie
spoczynku ciała w ruch z ustaloną prędkością. Wyrażana jest przez:
\begin{equation}
E_{K} = \frac{mv^{2}}{2}
\end{equation}
Gdzie:\\
\emph{m} to masa ciała\\
\emph{v} to jego prędkość\\
W klasie \emph{CollisionShape} jest wyrażana przez:

\lstinputlisting[language=java, caption=Fragment pliku
CollisionShape.java,
label=lis:LinearEK,linerange={137-140}]{./listings/CollisionShape.java}


\textbf{Obrotowa energia kinetyczna}\\
Jest to rodzaj energii właściwy dla ciał nie będących pojedynczymi punktami a
zbiorem punktów materialnych, charakteryzujących się poza pozycją równiez
obrotem. Zdefinowana jest jako wartość pracy, jaka jest wymagana do wprowadzenia
ciała w ruch obrotowy z daną prędkością kątową. Wyrażana jest przez:
\begin{equation}
E_{K} = \frac{I\omega^{2}}{2}
\end{equation}
Gdzie:\\
$ \omega $ to wartość prędkości kątowej ciała względem jego środka masy.\\
\emph{I} to skalarna wartość momentu bezwładności ciała.\\ Moment bezwładności
jest wielkością tensorową. W przypadku obrotu wokół jednej osi układu
współrzędnych jest jednak dopuszczalne, dla uproszczenia, użycie jego
składowej wartości odpowiadającej osi obrotu jako wartości skalarnej.\\
\\
\newpage
Moment bezwładności (\emph{moment of inertia}) to miara bezwładności ciała
w ruchu obrotowym względem określonej, ustalonej osi obrotu. Odgrywa prawie taką samą
rolę w dynamice ruchu obrotowego jak masa w dynamice ruchu postępowego. Opisuje
relacje między momentem pędu, energią kinetyczną a prędkością kątową jak masa
między pędem, energią kinetyczną a prędkością. Moment bezwładności pojedynczego
punktu materialnego jest iloczynem jego masy \emph{m} i kwadratu odległości od
osi obrotu \emph{r}:
\begin{equation}
I = mr^{2}
\end{equation}

\begin{figure}[h]
\centering
\includegraphics{./img/inertia.png}
\caption{Punkt i jego oś obrotu.}
\label{fig:inertia}
\end{figure}

Zaś dla ciała składającego się z \emph{n} punktów, moment bezwładności jest sumą
momentów bezwładności wszystkich punktów.
\begin{equation}
I = \sum_{i=1}^{n} m_{i}r_{i}^{2}
\end{equation}
Dla zaimplementowanych kształtów w omawianynej bibliotece obudowującej wartości
momentu bezwładności są następujące:\\
Dla kuli (\emph{sphere}):\\

\begin{figure}[h]
\centering
\includegraphics{./img/inertiaSphere.png}
\caption{Moment bezwładności kuli.}
\label{fig:inertiaSphere}
\end{figure}

\begin{equation}
I = \frac{2}{5}mr^{2}
\end{equation}
Dla prostopadłościanu (\emph{box}):\\

\begin{figure}[h]
\centering
\includegraphics{./img/inertiaBox.png}
\caption{Prostopadłościan z zaznaczoną osią obrotu.}
\label{fig:inertiaBox}
\end{figure}

Dla dowolnej osi obrotu $ \hat{n} $ przechodzącej przez środek masy sześcianu,
moment bezwładności jest określany przez następuące równanie:
\begin{equation}
I = m\hat{n}^{T}\hat{I}\hat{n} = m
\begin{bmatrix}n_{x}&n_{y}&n_{z}\end{bmatrix}
\begin{bmatrix}y^{2}+z^{2}&-xy&-xz\\-yx&x^{2}+z^{2}&-yz\\-zx&-zy&x^{2}+y^{2}\end{bmatrix}
\begin{bmatrix}n_{x}\\n_{y}\\n_{z}\end{bmatrix}
\label{eq:boxInertia}
\end{equation}
Gdzie:\\
$\hat{I}$ jest wartością tensora momentu bezwładności ciała.\\
Wartości $n_{x}$, $n_{y}$ i $n_{z}$ to składowe wektora $\hat{n}$.\\
Wartości \emph{x}, \emph{y} i \emph{z}, to kolejno szerokość, wysokość i długość
rozważanego prostopadłościanu.\\ \\
Nie jest konieczne implementowanie momentu bezwładności osobno dla każdego typu
bryły. Silnik Bullet przechowuje wartość macierzy momentu bezwładności dla
każdego obiektu klasy \emph{btRigidBody}.

\lstinputlisting[language=c++, caption=Fragment pliku
btRigidBody.h,
label=lis:RigidBodyh,linerange={55-60}]{./listings/btRigidBody.h}

Pole \emph{m\_invInertiaTensorWorld} zawiera odwrotną macierz momentu
bezwładności w odniesieniu do macierzy świata symulacji.
\newpage

\lstinputlisting[language=c++, caption=Fragment pliku
CollisionShape.cpp,
label=lis:CollisionShapecpp,linerange={162-168}]{./listings/CollisionShape.cpp}

W 6. linijce listingu \ref{lis:CollisionShapecpp} realizowane jest mnożenie wektorów
\emph{n} (transpozycja jest realizowana przez iloczyn skalarny (\emph{dot})
dwóch powstałych wektorów) z równaia \ref{eq:boxInertia}.

\lstinputlisting[language=java, caption=Fragment pliku
CollisionShape.java,
label=lis:CollisionShapejava,linerange={38-38,142-145,
147-153}]{./listings/CollisionShape.java}

Ponieważ wyciągana wartość w kodzie natywnym to odwrotna wartość momentu
bezwładności, w linijce 4 zostaje ona sprowadzona do wartości prawidłowej. Jako
oś obrotu zostaje obrany znormalizowany wektor prędkości kątowej (ln. 10).\\


\textbf{Całkowita energia kinetyczna}\\
Podsumowując, dla testów w tej podsekcji będzie sprawdzone czy
spełniony jest następujący warunek dla \emph{n} ciał:
\begin{equation}
E_{K} = \sum_{i=1}^{n}\left(\frac{mv^{2}}{2} + \frac{I\omega^{2}}{2}\right) =
const.
\end{equation}
\newpage
Warunek jest sprawdzany przez metodę:
\lstinputlisting[language=java, caption=Fragment
pliku CollisionShape.java,
label=lis:CollisionShapejava2,linerange={155-158}]{./listings/CollisionShape.java}


\textbf{Energia potencjalna}\\
Drugim rodzajem energii występującym w fizyce klasycznej jest energia
potencjalna. Jest to energia jaką posiada ciało za sprawą swojej pozycji i
pozycji innych ciał względem jego. Podobnie jak w przypadku energii
kinetycznej, rozważane będą dwa rodzaje energii potencjalnej: grawitacji i
sprężystości.\\

\textbf{Energia potencjalna grawitacji}\\
Energia ta jest wynikiem znajdowania się ciała w polu grawitacynym innych ciał.
Ogólnym wzorem na wyznaczenie jej wartości dla ciała o masie \emph{m}, przy
założeniu, że ciała mają kształt kuli jest:

\begin{equation}
E_{P} = mG\sum_{i=1}^{n}\frac{m_{i}}{r_{i}}
\label{eq:epgravity}
\end{equation}
Gdzie:\\
\emph{G} to stała grawitacji.\\
$ m_{i} $ jest masą \emph{i}-tego ciała tworzącego pole grawitacyjne.\\
$ r_{i} $ to odległość badanego ciała od \emph{i}-tego ciała.\\

Zakładając, że ciałem wytwarzającym pole grawitacyjne jest kula ziemska i że
przyspieszenie ziemskie \emph{g} wynosi $ GM_{Z} $ wzór
\ref{eq:epgravity} przyjmuje po uproszczeniu postać:

\begin{equation}
E_{P} = mgr_{Z}
\end{equation}
Gdzie:\\
$ r_{Z} $ to odległość środka ciała od środka Ziemi\\
Ponieważ podczas testów istotne będą jedynie zmiany wartości energii
potencjalnej:

\begin{equation}
\Delta E_{P} = mg\Delta h
\end{equation}

Do obliczenia wartości zostanie wykorzystana metoda klasy \emph{CollisionShape}.
Obraną ustaloną wysokością będzie współrzędna \emph{y} ciała.
\newpage
\begin{lstlisting}[language=Java,
caption=Fragment pliku CollisionShape.java,label=lis:epgravity]
float getGravitationalPotentialEnergy()
{
	return mass*9.81f*getTranslation().y;
}
\end{lstlisting}

\textbf{Energia potencjalna sprężystości}\\
Ten rodzaj energii jest właściwy dla ciał posiadających sprężystość. Pojawia się
gdy ciało zostaje odkształcone. Jej wartość jest proporcjonalna do siły
wymuszającej powrót do jego stabilnego stanu. Ogólnym wzorem wyznacząjącym
wartość tej energii dla sprężyny jest:

\begin{equation}
\Delta E_{P} = \frac{kx^{2}}{2}
\end{equation}
Gdzie:\\
\emph{k} to współczynnik sprężystości ciała.\\
\emph{x} jest odległością na jaką została odkształcona spręzyna.\\
 \\
Energia potencjalna sprężystości jest właściwa tylko dla ciał sprężystych,
dlatego zostaje zaimplementowana jedynie w klasie \emph{Spring}.

\begin{lstlisting}[language=Java,
caption=Obliczanie energii potencjalnej spręzystości,label=lis:epelastic]
public class Spring
{
	...
	
	private CollisionShape rb1, rb2;
	private Vector3 relation;
	private float stiffness;
	
	public Spring(DynamicsWorld dw, CollisionShape rb1, CollisionShape rb2, Vector3 frameA, Vector3 frameB, boolean linear)
	{
		id = constructor(dw.id, rb1.id, rb2.id, frameA, frameB, linear);
		this.rb1 = rb1;
		this.rb2 = rb2;
		relation = rb2.getTranslation().subtract(rb1.getTranslation());
	}
	
	public void setupDof(Dof index, float stiffness, float damping)
	{
		enable(index, true);
		setDamping(index, damping);
		setStiffness(index, stiffness);
		this.stiffness = stiffness;
	}
	
	public float getElasticPotentialEnergy()
	{
		Vector3 stablePos = relation.clone().rotate(rb1.getRotation()).add(rb1.getTranslation());
		float x = stablePos.subtract(rb2.getTranslation()).length();
		return (float)Math.pow(x, 2)*stiffness/2.0f;
	}
	
	...
}
\end{lstlisting}
Dane o ciałach \textbf{A} i \textbf{B} (o których była mowa w paragrafie
\ref{sec:spring}), przechowane są w momencie tworzenia obiektu przez konstruktor
(jako \emph{rb1} i \emph{rb2} ln. 12-13). Zachowany jest również wektor relacji
pozycji ciała \textbf{A} do ciała \textbf{B} (ln. 14), w celu określenia
stabilnej pozycji ciała \textbf{B}. Współczynnik sprężystości (w tym miejscu
oznaczony jako \emph{stiffness}) także jest zachowywany do póżniejszych obliczeń
(ln. 22). Wartość energii potencjalnej sprężystości jest zwracana przez metodę
\emph{getElasticPotentialEnergy}. Wektor \emph{stablePos} (ln. 27) jest stabilną
pozycją ciała \textbf{B} względem środka świata symulacji. Odległość między
\emph{stablePos} a pozycją ciała \textbf{B} stanowi miarę odkształcenia
\emph{x} (ln. 28).

\subsubsection{Odbicie sprężyste jednego ciała}\label{sec:odbicie1ciala}
Na początek zostanie rozważony najprostszy przypadek z jedną kulką
odbijającą się kolejno od dwóch idealnie sprężystych ścianek. Ponieważ w
testach wykonywanych w tej podsekcji nie są zakładane oddziaływania pomiędzy
ciałami, zostaną rozważone jedynie zmiany energii kinetycznej. Do tego testu
wykorzystana została scena prezentowana na listingu
\ref{lis:SimpleSnookerScene}. Test ma na celu zbadanie rzeczywistej zależności
zmian energii kinetycznej ciała przy odbiciach od jego współczynnika
sprężystośści.

\lstinputlisting[language=Java,
caption=Scena testująca przypadek z jednym ciałem,
label=lis:SimpleSnookerScene]{./listings/SimpleSnookerScene.java}
\newpage
Na niesprężystym (ln. 57) i całkowicie śliskim (ln. 55) podłożu zostaje
umieszczona kulka (ln. 59), która przez nadaną jej prędkość początkową (ln. 62)
odbija się kolejno od ścianek (ln. 49, 50). Sprężystość (\emph{restitution})
kulki jak i ścianek jest regulowana na początku każdego testu (ln. 73, 74),
która dla pierwszego wynosi 0,9 (ln. 18) i jest liniowo zwiększana dla kolejnych
dziesięciu testów (ln. 21, 24, 94) aż do osiągnięcia wartości 1 (gdzie
teoretycznie energia kulki powinna być stała).
Dla każdej testowanej wartości przewidziano 20 odbić (ln. 22, 23, 81-97).
Energia kinetyczna kulki jest zapisywana do pliku przy każdym odbiciu (ln.
81-87).

\begin{figure}[h]
\centering
\includegraphics[scale = 0.5]{./img/SimpleSnookerScene.png}
\caption{Render sceny z odbiciem jednego ciała.}
\label{fig:render1}
\end{figure}

\begin{figure}[h]
\input{./diag/EKjednoCialo.tex}
\caption{Zależność energii kinetycznej kulki przy kolejnych jej odbiciach od wartości
sprężystości.}
\label{fig:EKjednoCialo}
\end{figure}

Jak widać na wykresie z rysunku \ref{fig:EKjednoCialo} w doświadczeniu nie
osiągnięto spodziewanych rezultatów. Dla sprężystości o wartości 1 energia
kinetyczna powinna być stała, natomiast tutaj gwałtownie wzrasta. Wydaje się,
że dla utrzymania stałej energii kinetycznej konieczne jest użycie niższej
wartości. Dla polepszenia widoczności wykres na rysunku
\ref{fig:EKjednoCialo2} zawiera wartości energii kinetycznej dla wartości
sprężystości od 0,94 do 0,97.

\begin{figure}[h]
\input{./diag/EKjednoCialo2.tex}
\caption{Zależność energii kinetycznej kulki przy kolejnych jej odbiciach od wartości
sprężystości.}
\label{fig:EKjednoCialo2}
\end{figure}

Przy początkowej prędkości 5$\frac{m}{s}$ i masie 1 kg (listing
\ref{lis:SimpleSnookerScene} ln. 72, 59) energia kinetyczna kulki powinna mieć
stałą wartość energii kinetycznej 12,5.
\begin{equation}
E_{K} = \frac{mv^{2}}{2} = \frac{1kg*(5\frac{m}{s})^{2}}{2} =
12,5J
\end{equation}
Z prezentowanego wykresu wynika, że najbardziej odpowiednia wartość
współczynnika sprężystości kulki i ścianek mieści się między 0,945 a 0,955.\\
\newpage
Dla ustalenia bardziej szczegółowej wartości test został powtórzony dla
następujących parametrów z listingu \ref{lis:SimpleSnookerScene}:

\lstinputlisting[language=Java,caption=Parametry dla testu z wartościami
wspólczynnika sprężystości od 0.945 do 0.955,
label=lis:SimpleSnookerScene_additional]{./listings/SimpleSnookerScene_additional.java}
  
Ilość odbić została zwiększona dwukrotnie, dzięki czemu możliwe jest sprawdzenie
czy wyrównany poziom energii będzie się utrzymywać. Wyniki zostały przedstawione
na rysunku \ref{fig:EKjednoCialo3}.

\begin{figure}[h]
\input{./diag/EKjednoCialo3.tex}
\caption{Zależność energii kinetycznej kulki przy kolejnych jej odbiciach od wartości
sprężystości.}
\label{fig:EKjednoCialo3}
\end{figure}

Jak widać poziom energii nie utrzymuje się dla zwiększonej ilości odbić. W
dodatku w losowych momentach (na prezentowanym wykresie dla wartości
współczynnika sprężystości 0,945 dla 27. odbicia) można zaobserwować jego
gwałtowne wzrosty. Dla złagodzenia efektów tych wzrostów na poniższym wykresie
przedstawiono uśredniony wynik dziesięciu testów. Zostało to przedstawione na
wykresie z rysunku \ref{fig:EKjednoCialo4}.

\begin{figure}[h]
\input{./diag/EKjednoCialo4.tex}
\caption{Zależność energii kinetycznej kulki przy kolejnych jej odbiciach od wartości
sprężystości dla dziesięciu testów.}
\label{fig:EKjednoCialo4}
\end{figure}

Spadki wartości energii kinetycznych sugerują, że nawet przy początkowo dobrze
dobranych współczynnikach sprężystości, przy większej ilości odbić energia nie
utrzymuje stałej wartości. Przy wartości współczynnika równej jedności, energia
nie utrzymuje stałej wartości, a wzrasta. Co jest tego przyczyną? \\
W poszukiwaniu odpowiedzi na to pytanie można spojrzeć na wyniki poprzednich
testów rozpatrując osobno zapisy energii kinetycznej liniowej i obrotowej.
Poniżej przedstawiono fragment zapisu dla testu przy watrości współczynnika
sprężystości 0,98 (wartości energi liniowej energii kinetycznej znajdują się
po lewej stronie, a obrotowej po lewej):

\lstinputlisting[language=xml, caption=Wartości energii kinetycznej,
  label=lis:linearAngle,linerange={6-12}]{./listings/0,98.txt}

Okazuje się, że nawet na całkowicie śliskim podłożu ciało uzyskuje obrotową
energię kinetyczną, co nie powinno mieć miejsca. Występowanie obrotu nie jest
jednak spowodowane tarciem ciała o podłoże, a wynikiem błędów zaokrągleń
kalkulacji silnika przy zderzeniach kulki ze ściankami.\\
\newpage
Na listingu \ref{lis:linearAngle} można zaobserwować gwałtowne zmiany obu
energii, jednak wzrost energii kinetycznej liniowej jest zawsze poprzedzony
wzrostem energii kinetycznej obrotowej. Liniowa energia kinetyczna sama w sobie
nie ulega gwałtownym wzrostom. Przyczyną tego jest wzrost energii całkowitej.\\
Podczas analitycznego rozważania odbicia ciała, możliwe jest dokładne ustalenie
czasu i miejsca zderzenia poprzez rozwiązanie odpowiedniego równania ruchu. W
przypadku symulacji zderzenia ciał przez silnik fizyczny, symulacja ta jest
dzielona na kroki. Każdy krok odpowiada minięciu kwantu czasu, o ustalonej z
góry wartości i wszystkie ciała uczestniczące w symulacji poruszają się adekwatnie do
swojej prędkości. Prawie niemożliwe jest więc uzyskanie sytuacji w której
zderzenie powierzchni sferycznej z płaską będzie tylko jednym punktem (tak jak
zostało to zaobrazowane na rysunku \ref{fig:zderzenie1}).

\begin{figure}[H]
\centering
\includegraphics{./img/zderzenie1.png}
\caption{Zaobrazowanie zderzenia ciała przy obliczeniach teoretycznych.}
\label{fig:zderzenie1}
\end{figure}

Podczas symulacji, zderzenia nie są punktami, tylko powierzchniami.
Silnik Bullet do obliczenia parametrów reakcji na zderzenie potrzebuje
określenia obszaru zderzenia jako punktu (który jest wybrany z powierzchni
obszaru zderzenia oznaczonego na ilustracji \ref{fig:zderzenie2} czerwoną
linią). Niestety, im większy jest obszar zderzenia tym większe jest
prawdopodobieństwo błędu w wyborze odpowiedniego punktu. Przesunięcie tego
punktu względem właściwego umiejscowienia pozycji zderzenia wynikające z
niedokładności obliczeniowej decyduje o nadmiarze lub niedoborze obrotowej
energii kinetycznej.

\begin{figure}[H]
\centering
\includegraphics{./img/zderzenie2.png}
\caption{Zaobrazowanie zderzenia ciała przy obliczeniach teoretycznych.}
\label{fig:zderzenie2}
\end{figure}

Aby zminimalizować możliwą wielkość obszaru zderzenia można zmniejszyć kwant
czasu, minimalizując odległości przebywane przez ciała w każdym kroku
symulacji.\\
Aby tego dokonać należy przyjrzeć się prototypowi funkcji \emph{stepSimulation}.

\lstinputlisting[language=c++, caption=Prototyp funkcji stepSimulation,
label=lis:stepSimulation]{./listings/stepSimulation.cpp}

Funkcja ta jest wywoływana w celu zaktualizowania symulacji o pewien
czas (wywoływana jest dla każdej renderowanej klatki aplikacji). Według
\emph{Bullet User Manual}$ ^{1} $ jej poszczególne
parametry oznaczają:\\
\\
\textbf{timeStep}: całkowita ilość czasu jaka musi minąć w danym kroku. W
symulacjach jest to najczęściej odstęp czasu pomiędzy wyświetleniem poprzedniej
i następnej klatki.\\
\textbf{fixedTimeStep}: silnik Bullet każdy krok symulacji dzieli na podkroki o
długości okreslanej tym parametrem. To właśnie ten parametr decyduje o
dokładności symulacji. Jeśli \emph{timeStep} jest mniejsze od
\emph{fixedTimeStep} ruch ciał zostaje interpolowany. Domyślna wartość parametru
to $ \frac{1}{60} $ sekundy.\\
\textbf{maxSubSteps}: czasem z powodu spowolnień pracy silnika lub aplikacji
wartość \emph{timeStep} może być bardzo duża. Aby zapobiec zbyt dużym przeskokom
w animacji parametr ten określa maksymalną ilość podkroków jakie mogą być
wykonane w jednym kroku symulacji. Innymi słowy relacja parametrów powinna
wyglądać następująco:\\
\begin{equation}
timeStep < fixedTimeStep * maxSubSteps
\end{equation}

Domyślną wartością \emph{maxSubSteps} jest 1.

Kolejnym testem jest zmodyfikowany test z listingu \ref{lis:SimpleSnookerScene}.
Tym razem nie jest badana zależność energii kinetycznej od współczynnika
sprężystości, a od parametru \emph{fixedTimeStep}. 

\lstinputlisting[language=Java,
  label=lis:SimpleSnookerSceneFts,caption=Scena
  testująca zależność energii
  kinetycznej od fixedTimeStep]{./listings/SimpleSnookerSceneFts.java}

Wykres z rysunku \ref{fig:EKjednoCialoFTS} przedstawia zależność energii
kinetycznej od odbicia (poszczególne linie reprezentują wartości współczynnika
\emph{ftsFactor}). Dla czytelności wykresu $ fixedTimeStep =
\frac{1}{ftsFactor} $. Współczynnik sprężystości został ustawiony na 1.
Prędkość ciała wynosi 5$\frac{m}{s}$.

\begin{figure}[H]
\input{./diag/EKjednoCialoFTS.tex}
\caption{Zależność energii kinetycznej kulki przy kolejnych jej odbiciach od wartości
sprężystości dla różnych wartości kroków.}
\label{fig:EKjednoCialoFTS}
\end{figure}

\newpage
Dla lepszej czytelności wykresu na rysunku \ref{fig:EKjednoCialoFTSz} znajdują
się wartości energii dla pierwszych 15 odbić:

\begin{figure}[H]
\input{./diag/EKjednoCialoFTSz.tex}
\caption{Zależność energii kinetycznej kulki przy kolejnych jej odbiciach od wartości
sprężystości dla różnych wartości kroków.}
\label{fig:EKjednoCialoFTSz}
\end{figure}

Z wyników można odczytać, że przy długości podkroku $ \frac{1}{260} $ sekundy
zasada zachowanaia energii zostaje spełniona. Okazuje się również, że wartość
tego parametru musi być odpowiednio dobrana (przy innych widoczne są
niedobory/nadmiary energii). Aby sprawdzić czy jest ona uniwersalna, kolejny
test zostanie przeprowadzony dla wartości prędkości 10$\frac{m}{s}$. Wynik testu
został przedstawiony na rysunku \ref{fig:EKjednoCialoFTS10}.

\begin{figure}[H]
\input{./diag/EKjednoCialoFTS10.tex}
\caption{Zależność energii kinetycznej kulki przy kolejnych jej odbiciach od wartości
sprężystości dla różnych wartości kroków.}
\label{fig:EKjednoCialoFTS10}
\end{figure}

Jak widać odpowiednia wartość parametru \emph{fixedTimeStep} jest uzależniona od
wartości prędkości. Poprawne przeporowadzenie symulacji, w
której ważną rolę odgrywają odbicia sprężyste przy użyciu silnika Bullet jest
więc bardzo trudne.

\newpage
\subsubsection{Odbicie sprężyste wielu ciał}\label{sec:odbicieWieluCial}

W poprzednim doświadczeniu został zbadany przypadek odbicia jednego ciała.
Dla wartości kroku $ \frac{1}{260} $s i prędkości 5$ \frac{m}{s} $ energia
kinetyczna zachowała stałą wartość. Jak wyglądać będzie zależność energii
kinetycznej od czasu w tych samych warunkach, jeśli w symulacji będzie
uczestniczyć wiele ciał? Przy pomocy poniższej sceny sprawdzone zostanie jaki
wpływ ma parametr \emph{fixedTimeStep} na łączną energię poruszających się ciał.

\begin{figure}[H]
\centering
\includegraphics[scale = 0.5]{./img/shot_2.png}
\caption{Render sceny z odbiciem wielu ciał.}
\label{fig:shot_2}
\end{figure}

\lstinputlisting[language=Java,
  label=lis:ClosedSnookerScene,caption=Scena
  testująca przypadek z wieloma ciałami]{./listings/ClosedSnookerScene3.java}
  
Na obszarze otoczonym ściankami (ln. 44-50) zostaje umieszczonych dziewięć (ln.
60-66) idealnie sprężystych (ln. 69) kulek. Kulki rozprzestrzeniają się w
losowych kierunkach z prędkością 5$ \frac{m}{s} $ (ln. 64). Wartość energii
kinetycznej całego układu jest rejestrowana co 20 klatek (ln. 22, 105-111).
Każdy test trwa 20*100 klatek (ln. 22, 24, 94), w każdym z nich wartość
parametru \emph{ftsFactor} jest zwiększana (ln. 101).\\
Wykres na rysunku \ref{fig:EKwieleCial} zależności całkowitej energii układu od
czasu (klatek animacji) dla różnych wartości \emph{ftsFactor}, a tym samym
długości podkroku symulacji. Dla większej dokładności wykonanych zostało
dziesięć takich testów i wyciągnięta została z nich średnia wartość energii.

\begin{figure}[H]
\input{./diag/EKwieleCial.tex}
\caption{Zależność energii kinetycznej kulki przy kolejnych jej odbiciach od wartości
sprężystości.}
\label{fig:EKwieleCial}
\end{figure}

Jak widać do pewnej wartości parametru \emph{ftsFactor}(dla prędkości 5$
\frac{m}{s} $: od 360 do 420) wartość łącznej energii rośnie w czasie. Po
przekroczeniu tej wartości energia zaczyna maleć. Dla wartości \emph{ftsFactor}
równej 260 energia układu nie pozostaje stała w czasie, jak miało to miejsce w
teście dla jednego ciała. Dzieje się tak ponieważ podczas symulacji, ciała
poprzez zderzenia mogą przekazywać sobie energię. Niemożliwe jest przez to
utrzymanie stałej prędkości co powoduje, że dla każdego z ciał musi być
ustawiona inna wartość parametru \emph{fixedTmeStep}. Stabilność układu zostaje
więc naruszona.\\
Oznacza to, że silnik Bullet nie nadaje się do symulacji w których wymagane jest
badanie oddziaływań ciał sprężystych.\\
Fakt, że symulacje nie są dokładne dla wysokiego współczynnika sprężystości i
niskiego tarcia został nawet wspomniany w kodzie źródłowym biblioteki Bullet.

\lstinputlisting[language=c++, caption=Fragment kodu pliku btRigidBody.h z
biblioteki Bullet,
label=lis:RigidBody,linerange={126-129}]{./listings/btRigidBody.h}

%\subsection{Rzut ukośny}

\subsubsection{Równia pochyła}
Ten test ma na celu sprawdzenie czy zachowywana jest energia kinetyczna i
potencjalna dla ciała staczającego się po równi pochyłej z tarciem.
Przetestowane zostaną dwa kształty staczających się brył: sześcian oraz kula.
Wartości doświadczalnej prędkości ciał w konkretnych punktach zostaną porównane
ze spodziewanymi wartościami teoretycznymi.\\
W przypadku sześcianu, wartość teoretyczna prędkości zostaje obliczona z zasady
zachowania energii. Energia mechaniczna jest określona jako suma energii
kinetycznej, potencjalnej i spadku wartości energii spowodowanego siłą tarcia.
Rozkład sił na równi pochyłej przedstawiono na rysunku \ref{fig:rownia}.

\begin{figure}
\centering
\includegraphics[scale = 0.6]{./img/rownia.PNG}
\caption{Rozkład sił na równi pochyłej.}
\label{fig:rownia}
\end{figure}

Korzystając z tych danych wartość prędkości można obliczyć:

\begin{equation}
E_{P} = E_{K} + E_{T}
\end{equation}
Gdzie:\\
$ E_{P} $ jest wartością energii potencjalnej ciała równej \emph{mgh}.\\
$ E_{K} $ to wartość energii kinetycznej równej $ \frac{mv^{2}}{2} $.\\
$ E_{T} $ jest wartoscią spadku energii spowodowanej tarciem równym $ fmgh \cos
\alpha $.\\
Czyli:\\
\begin{equation}
mgh = \frac{mv^{2}}{2} + fmgh \cos \alpha
\end{equation}
\begin{equation}
\label{eq:boxVelocity}
v(h) = \sqrt{2gh(1-f \cos \alpha)}
\end{equation}
Gdzie:\\
\emph{f} jest współczynnikiem tarcia ciała o powierzchnię.\\
Staczającej się bryle o kształcie kuli towarzyszy również poślizg, a
siła tarcia nie powoduje opóźnienia staczania się a wprawia ciało w obrót.
Aby ciało poruszało się bez poślizgu przyspieszenie kątowe ($ \varepsilon $) musi
być odpowiednie dla przyspieszenia liniowego staczania (\emph{a}).
\begin{equation}
a = \varepsilon r
\end{equation}
Gdzie:\\
\emph{r} jest promeniem kuli.\\
Korzystając z poniższych zależności:
\begin{equation}
a = \frac{F_{1}}{m}
\end{equation}
\begin{equation}
F_{1} = mg \sin \alpha
\end{equation}
Momenty sił ciała również muszą być zgodne:
\begin{equation}
Tr = I \varepsilon
\end{equation}
Gdzie:\\
\emph{I} to wartość momentu bezwładności kuli równego $ \frac{2}{5}mr^{2} $.\\
\emph{T} jest wartością siły tarcia z rysunku \ref{fig:rownia} równej $ fF_{2}
= fmg \cos \alpha $.
Z tych zależności otrzymać można:
\begin{equation}
f = \frac{2}{5} \tg \alpha
\end{equation}
Przy założeniu że kąt nachylenia równi $ \alpha = 45^{\circ} $ można przyjąć
że:
\begin{equation}
f = \frac{2}{5}
\label{eq:friction}
\end{equation}

W przypadku obliczeń prędkości dla ciała kulistego, przy założeniu że
współczynnik tarcia jest taki jak we wzorze \ref{eq:friction}, energia
potencjalna musi być równa sumie energii kinetycznej liniowej i obrotowej.
\begin{equation}
E_{P} = E_{KL} + E_{KR}
\end{equation}
\begin{equation}
mgh = \frac{mv^{2}}{2} + \frac{I\omega^{2}}{2}
\end{equation}
\begin{equation}
v(h) = \sqrt{\frac{10}{7}gh}
\label{eq:ballVelocity}
\end{equation}
Natomiast uwzględniając wartość współczynnika tarcia z równania
\ref{eq:friction} we wzorze na prędkość zsuwającego się sześcianu -
\ref{eq:boxVelocity}:
\begin{equation}
v(h) = \sqrt{2gh\frac{5-\sqrt{2}}{5}}
\label{eq:ballVelocity2}
\end{equation}

Do przetestowania wartości prędkości ciał na równi pochyłej wykorzystana
zostanie następująca scena:

\lstinputlisting[language=Java, caption=Kod sceny użytaj do testowania prędkości
ciał na równi pochyłej,
label=lis:InclinedPlaneScene]{./listings/InclinedPlaneScene.java}

Z podstawy o długości 30 metrów (ln. 23, 25), staczają się dwa ciała (ln. 26, 
27). Podstawa jest nachylona pod kątem $ 45^{\circ} $ (ln. 30). Współczynnik
tarcia jest zgodny z wartością wynikającą z równania \ref{eq:friction} (ln. 37,
42). Pomiary wysokości i prędkości ciał są zapisywane w pliku w formacie CSV
(ln. 42, 50).

\begin{figure}
\centering
\includegraphics[scale=0.5]{./img/rowniaScreen.PNG}
\caption{Widok staczających się ciał po równi pochyłej.}
\label{fig:rowniaScreen}
\end{figure}

\begin{figure}
\centering
\input{diag/rowniaBox.tex}
\caption{Wykres zależności prędkości od wysokości dla ciała o kształcie
sześcianu.}
\label{fig:boxDiagram}
\end{figure}

\begin{figure}
\centering
\input{diag/rowniaBall.tex}
\caption{Wykres zależności prędkości od wysokości dla ciała o kształcie
kuli.}
\label{fig:ballDiagram}
\end{figure}

Zestawienie doświadczalnych pomiarów prędkości i teoretycznych wyników
obliczonych ze wzorów \ref{eq:boxVelocity} dla sześcianu i
\ref{eq:ballVelocity2} dla kuli przedstawiają wykresy na rysunkach
\ref{fig:boxDiagram} i \ref{fig:ballDiagram}. Różnica wyników na wykresie jest
niewielka, co potwierdza stwierdzenie z końca testu z sekcji
\ref{sec:odbicieWieluCial}: przy obecnym tarciu i braku sprężystości wynik
symulacji ma niski odstęp od teoretycznego.

\subsubsection{Kołyska Newtona} \label{sec:kolyskaNewtona}
W tym teście, tak jak w poprzednim, sprawdzona zostanie zasada zachowania
energii zarówno z uwzględnieniem energii kinetycznej jak i potencjalnej.
Z tą różnicą, że brana pod uwagę będzie również sprężystość ciał tak jak w
sekcjach \ref{sec:odbicie1ciala} i \ref{sec:odbicieWieluCial}. W celu
przeprowadzenia tego testu zostanie użyta poniższa scena:

\lstinputlisting[language=Java, caption=Kod sceny użytej do testowania
zachowania energii dla kołyski Newtona,
label=lis:NewtonPendulumScene]{./listings/NewtonPendulumLogScene.java}

Scena składa się z czterech kulek (ln. 24-33) zawieszonych na nierozciągliwych
niciach (ln. 37-42). Kulka położona najbardziej z lewej strony posiada prędkość
początkową (ln. 35), która wprawia w ruch wahadło. Podobnie jak w przypadku
testu z sekcji \ref{sec:odbicie1ciala} przeprowadzone zostało 10 testów dla
różnych wartości współczynnika spręzystości zmienijącego się od 0,99 do 0,91
(ln.
73-81). Wynik testu przedstawiono na rysunku \ref{fig:wahadloNewtona1}.

\begin{figure}
\centering
\includegraphics[scale=0.5]{img/newtonPendulum.png}
\caption{Wizulalizacja symulacji wahadła Newtona.}
\label{fig:newtonPendulum}
\end{figure}

\begin{figure}
\centering
\input{diag/newton.tex}
\caption{Wykres zależności energii od czasu dla wahadła Newtona.}
\label{fig:wahadloNewtona1}
\end{figure}

Z wykresu wynika, że wartość współczynnika sprężystości przy którym całkowita
energia się nie zmienia jest niższa niż 0,91. W celu zwiększenia precyzji
obliczeń test został powtórzony dla wartości od 0,94 do 0,87, dla dwukrotnie
większego odstępu czasu. Jego wynik przedstawia wykres na rysunku
\ref{fig:wahadloNewtona2}. Wywnioskować można, że najbezpieczniej jest
przeprowadzić symulację z niezerowym współczynnikiem tłumienia. Tak jak w
przypadku prawdziwej symulacji, kołyska się zatzymuje.

\begin{figure}
\centering
\input{diag/newton2.tex}
\caption{Wykres zależności energii od czasu dla wahadła Newtona.}
\label{fig:wahadloNewtona2}
\end{figure}

Dla żadnej wartości współczynnika, wartość energii nie utrzymuje stałego
poziomu. Podobnie jak w przypadku testu z sekcji \ref{sec:odbicie1ciala}, przy
występowaniu wysokiej wartości współczynnika sprężystości wynik nie jest
przybliżeniem wartości rzeczywistej.

\subsubsection{Model ciała sprężystego}
Test w tej sekcji ma na celu przetestowanie zachowania energii sprężystości w
symulacjach. Utworzony zostanie model ciała sprężystego (kilka ciał kulistych
połączonych sprężynami), zostanie on wprawiony w ruch i sprawdzone zostaną
przemiany energii składowych sprężyn.\\
Test ten zostanie przeprowadzony przy pomocy sceny z listingu
\ref{lis:JellyLogScene}.

\lstinputlisting[language=Java, caption=Kod sceny użytej do testowania
zachowania energii dla ciała elastycznego,
label=lis:JellyLogScene]{./listings/JellyLogScene.java}

Kilka sprężyn połączonych ze sobą tworzą prostokątne elastyczne ciało. Sprężyny
(ln. 38-55) połączone są ze sobą za pomocą kulistych łączników (ln. 23-37).
Współczynnik tłumienia sprężyn wynosi 1 (ln. 63-55, trzeci argument funkcji).
Łącznikowi o indeksie 7 zostaje dana początkowa prędkość (ln. 68) wprawiając w
ruch całe ciało. Suma energii potencjalnych wszystkich sprężyn (ln. 79) jest
zapisywana co 10 klatek (ln. 76) do pliku (ln. 69, 80). Scena wraz z oznaczonymi
numerami indeksów łączników została zaprezentowana na rysunku
\ref{fig:JellyScene}.

\begin{figure}
\centering
\includegraphics[scale=0.5]{img/JellyScene.png}
\caption{Test ciała elastycznego z oznaczonymi indeksami łączników sprężyn.}
\label{fig:JellyScene}
\end{figure}

Wynik testu dla 40.000 ($ \frac{40000 klatek}{60 fps} \approx 667 s \approx 11
minut $) klatek został przedstawiony na rysunku \ref{fig:jellyTest2}.

\begin{figure}
\centering
\input{diag/jelly2.tex}
\caption{Wykres zależności sumy energii sprężyn od czasu.}
\label{fig:jellyTest2}
\end{figure}

Energia układu zdaje się nieznacznie spadać. Dla większej dokładności powtórzono
test dla 200.000 klatek ($ \frac{200000 klatek}{60 fps} \approx 3333 s \approx
55 minut $). Zostało to przedstawione na rysunku \ref{fig:jellyTest}

\begin{figure}
\centering
\input{diag/jelly.tex}
\caption{Wykres zależności sumy energii sprężyn od czasu.}
\label{fig:jellyTest}
\end{figure}

Spadek energii został odnotowany po 10.000 klatek. Przez resztę testu wartość
energii utrzymuje stały poziom. Zasada zachowania energii dla ciał sprężystych
jest spełniona.
\newpage
\subsection{Zderzenie trzech kulek}
Jednym z problemów cyfrowej symulacji zjawisk fizycznych jest rozważanie kolizji
ciał w parach. Mogą przez to wystąpić błędy podczas równoczesnych zderzeń więcej
niż dwóch ciał. Ten test ma na celu zbadanie jak będą zachowywać się trzy ciała
kuliste po równoczesnym zderzeniu. Kod sceny testującej przedstawiono na
listingu \ref{lis:ThreeBallScene}.

\lstinputlisting[language=Java, caption=Kod sceny użytej do testowania
zachowania trzech kulek po równoczesnym zderzeniu,
label=lis:ThreeBallScene]{./listings/ThreeBallScene.java}

Trzy kulki ustawione tak, że tworzą trójkąt równoboczny (ln. 18-21, ułożenie
zostało przedstawione na rysunku \ref{fig:ThreeBall}). Po rozpoczęciu testu
zmierzają one w kierunku środka ciężkości trójkąta (ln. 23-25). Spodziewanym
wynikiem testu jest zmiana zwrotów wektorów prędkości ciał. Ich kierunek ma
zaś pozostać bez zmian.\\
Dla zaobrazowania przebiegu testu zarejestrowane zostały składowe wektorów
prędkości dla każdej z kul, przy rozpoczęciu testu jak i po zderzeniu.
Przedstawione one zostały w tabelach \ref{tab:velocities} i
\ref{tab:velocities2}. Jak jest widoczne w przedstawionych tabelach stosunek
składowych \emph{x} i \emph{z} wektorów prędkości ulega pomijalnie małej
zmianie. Oznacza to, że kierunki wektorów prędkości nie uległy zmianie. Zmieniły
się jedynie ich zwroty. Oznacza to, że silnik Bullet poprawnie rozpatruje
przypadki równoczesnych zderzeń więcej niż dwóch ciał.

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{img/ThreeBall.png}
\caption{Ułóżenie trzech ciał kulistych podczas testu.}
\label{fig:ThreeBall}
\end{figure}

\newpage
\begin{table}[H]
\centering
\input{./tab/Velocities.tex}
\caption{Zestawienie składowych prędkości ciał kulistych zaraz po rozpoczęciu
testu.}
\label{tab:velocities}
\end{table}

\begin{table}[H]
\centering
\input{./tab/Velocities2.tex}
\caption{Zestawienie składowych prędkości ciał kulistych po odbiciu kulek.}
\label{tab:velocities2}
\end{table}

\newpage
\section{Wnioski}
%\emph{Podsumowanie doświadczeń w pracy. Kiedy można wykorzystać silnik do
%symulacji fizycznych? Można też zwalić część winy złych wyników na spadek
%wydajności sprzętu przy dużym obciążeniu:).}\\
W tej sekcji zostały przedstawione wnioski dla poszczególnych celów pracy
opisanych w sekcji \ref{subsec:celeProjektu}. \\

\textbf{Uruchomienie silnika fizycznego na mobilnej platformie Android.}\\
Jak zostało to pokazane w sekcji \ref{sec:NDKuse}, kod otwartej biblioteki
Bullet można bez większych zmian skompilować na platformę ARM. Konieczne jest
tylko uwzględnienie odmiennego sposobu kompilacji projektu i sporządzenia
wymaganych przez Android NDK danych (jak plik \emph{Android.mk} przedstawiony w
załączniku \ref{att:Androidmk}). Jedyną trudnością w tworzeniu projektów
wykorzystujących silnik Bullet jest konieczność operowania na kodzie natywnym,
co zmusza programistę do sporządzenia odpowiednich klas opakowujących dla
środowiska Javy (jeśli kod sceny ma być pisany w tym języku). Ilość koniecznych
do stworzenia klas opakowujących jest jednak zależna od ilości wymaganych
przez projekt klas silnika Bullet.\\

\textbf{Wykorzystanie możliwości platformy mobilnej pod kątem symulacji
fizycznych.}\\
Fakt uruchomienia symulacji na urządzeniu mobilnym posiadającym odmienne
urządzenia wejścia niż typowa platforma PC, ma potencjał wprowadzenia
dodatkowych możliwości dla symulacji. Przedstawione w sekcji \ref{sec:dod}
metody wykorzystania niektórych z tych możliwości wykazują, że można je umieścić
w aplikacji bez większych trudności. Jedynym probemem, podobnie jak w przypadku
uruchomienia samego silnika Bullet, jest konieczność jednoczesnego wykonywania
operacji w kodzie natywnym i maszynie wirtualnej \emph{Dalvik}. Może to
doprowadzić do takich problemów jak przepełnienie lokalnego bufora NDK -
problemu opisanego w sekcji \ref{sec:debugDrawer}.\\
\newpage
\textbf{Ocena przydatności silnika w symulacjach fizycznych.}\\
W większości testowanych przypadków w sekcji \ref{sec:wykorzystanie}, nie
występują duże przekłamania dla wartości energii wewnętrznej ciał. Jak to jednak
zostało przedstawione w testach zawartych w sekcjach \ref{sec:odbicie1ciala} i
\ref{sec:kolyskaNewtona}, ciała posiadające duży współczynnik sprężystości lub
niski współczynnik tarcia mają tendencje do zaburzenia wartości energii
wewnętrznej. Zaleca się unikanie symulacji dla takich warunków. Dla zwiększenia
wydajności i dokładności symulacji możnaby zastosować obecnie testowaną
implementację silnika Bullet wykorzystującą standard OpenCL, który pozwala na
przeprowadzanie równoległych obliczeń korzystając z kart graficznych.
Implementacja ta może poprawić wydajność silnika nie tylko na platformach
stacjonarnych i mobilnych. Dzięki tworzonemu na wzór WebGL, opracowywanemu przez
firmę Nokia, standardowi WebCL możliwe jest również tworzenie aplikacji
przeglądarkowych. Rosnąca wydajność silników fizycznych nie tylko na platformach
stacjonarnych znacznie zwiększa ich dostępność.